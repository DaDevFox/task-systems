// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/inventory.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	InventoryService_AddInventoryItem_FullMethodName       = "/inventory.v1.InventoryService/AddInventoryItem"
	InventoryService_GetInventoryItem_FullMethodName       = "/inventory.v1.InventoryService/GetInventoryItem"
	InventoryService_ListInventoryItems_FullMethodName     = "/inventory.v1.InventoryService/ListInventoryItems"
	InventoryService_UpdateInventoryLevel_FullMethodName   = "/inventory.v1.InventoryService/UpdateInventoryLevel"
	InventoryService_GetInventoryStatus_FullMethodName     = "/inventory.v1.InventoryService/GetInventoryStatus"
	InventoryService_PredictConsumption_FullMethodName     = "/inventory.v1.InventoryService/PredictConsumption"
	InventoryService_SetConsumptionBehavior_FullMethodName = "/inventory.v1.InventoryService/SetConsumptionBehavior"
	InventoryService_ConvertUnits_FullMethodName           = "/inventory.v1.InventoryService/ConvertUnits"
)

// InventoryServiceClient is the client API for InventoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// InventoryService provides comprehensive inventory management
type InventoryServiceClient interface {
	// Item management
	AddInventoryItem(ctx context.Context, in *AddInventoryItemRequest, opts ...grpc.CallOption) (*AddInventoryItemResponse, error)
	GetInventoryItem(ctx context.Context, in *GetInventoryItemRequest, opts ...grpc.CallOption) (*GetInventoryItemResponse, error)
	ListInventoryItems(ctx context.Context, in *ListInventoryItemsRequest, opts ...grpc.CallOption) (*ListInventoryItemsResponse, error)
	UpdateInventoryLevel(ctx context.Context, in *UpdateInventoryLevelRequest, opts ...grpc.CallOption) (*UpdateInventoryLevelResponse, error)
	// Status and reporting
	GetInventoryStatus(ctx context.Context, in *GetInventoryStatusRequest, opts ...grpc.CallOption) (*GetInventoryStatusResponse, error)
	// Consumption prediction
	PredictConsumption(ctx context.Context, in *PredictConsumptionRequest, opts ...grpc.CallOption) (*PredictConsumptionResponse, error)
	SetConsumptionBehavior(ctx context.Context, in *SetConsumptionBehaviorRequest, opts ...grpc.CallOption) (*SetConsumptionBehaviorResponse, error)
	// Unit conversion
	ConvertUnits(ctx context.Context, in *ConvertUnitsRequest, opts ...grpc.CallOption) (*ConvertUnitsResponse, error)
}

type inventoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInventoryServiceClient(cc grpc.ClientConnInterface) InventoryServiceClient {
	return &inventoryServiceClient{cc}
}

func (c *inventoryServiceClient) AddInventoryItem(ctx context.Context, in *AddInventoryItemRequest, opts ...grpc.CallOption) (*AddInventoryItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddInventoryItemResponse)
	err := c.cc.Invoke(ctx, InventoryService_AddInventoryItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) GetInventoryItem(ctx context.Context, in *GetInventoryItemRequest, opts ...grpc.CallOption) (*GetInventoryItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInventoryItemResponse)
	err := c.cc.Invoke(ctx, InventoryService_GetInventoryItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) ListInventoryItems(ctx context.Context, in *ListInventoryItemsRequest, opts ...grpc.CallOption) (*ListInventoryItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInventoryItemsResponse)
	err := c.cc.Invoke(ctx, InventoryService_ListInventoryItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) UpdateInventoryLevel(ctx context.Context, in *UpdateInventoryLevelRequest, opts ...grpc.CallOption) (*UpdateInventoryLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateInventoryLevelResponse)
	err := c.cc.Invoke(ctx, InventoryService_UpdateInventoryLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) GetInventoryStatus(ctx context.Context, in *GetInventoryStatusRequest, opts ...grpc.CallOption) (*GetInventoryStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInventoryStatusResponse)
	err := c.cc.Invoke(ctx, InventoryService_GetInventoryStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) PredictConsumption(ctx context.Context, in *PredictConsumptionRequest, opts ...grpc.CallOption) (*PredictConsumptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PredictConsumptionResponse)
	err := c.cc.Invoke(ctx, InventoryService_PredictConsumption_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) SetConsumptionBehavior(ctx context.Context, in *SetConsumptionBehaviorRequest, opts ...grpc.CallOption) (*SetConsumptionBehaviorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetConsumptionBehaviorResponse)
	err := c.cc.Invoke(ctx, InventoryService_SetConsumptionBehavior_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryServiceClient) ConvertUnits(ctx context.Context, in *ConvertUnitsRequest, opts ...grpc.CallOption) (*ConvertUnitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvertUnitsResponse)
	err := c.cc.Invoke(ctx, InventoryService_ConvertUnits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InventoryServiceServer is the server API for InventoryService service.
// All implementations must embed UnimplementedInventoryServiceServer
// for forward compatibility.
//
// InventoryService provides comprehensive inventory management
type InventoryServiceServer interface {
	// Item management
	AddInventoryItem(context.Context, *AddInventoryItemRequest) (*AddInventoryItemResponse, error)
	GetInventoryItem(context.Context, *GetInventoryItemRequest) (*GetInventoryItemResponse, error)
	ListInventoryItems(context.Context, *ListInventoryItemsRequest) (*ListInventoryItemsResponse, error)
	UpdateInventoryLevel(context.Context, *UpdateInventoryLevelRequest) (*UpdateInventoryLevelResponse, error)
	// Status and reporting
	GetInventoryStatus(context.Context, *GetInventoryStatusRequest) (*GetInventoryStatusResponse, error)
	// Consumption prediction
	PredictConsumption(context.Context, *PredictConsumptionRequest) (*PredictConsumptionResponse, error)
	SetConsumptionBehavior(context.Context, *SetConsumptionBehaviorRequest) (*SetConsumptionBehaviorResponse, error)
	// Unit conversion
	ConvertUnits(context.Context, *ConvertUnitsRequest) (*ConvertUnitsResponse, error)
	mustEmbedUnimplementedInventoryServiceServer()
}

// UnimplementedInventoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInventoryServiceServer struct{}

func (UnimplementedInventoryServiceServer) AddInventoryItem(context.Context, *AddInventoryItemRequest) (*AddInventoryItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInventoryItem not implemented")
}
func (UnimplementedInventoryServiceServer) GetInventoryItem(context.Context, *GetInventoryItemRequest) (*GetInventoryItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInventoryItem not implemented")
}
func (UnimplementedInventoryServiceServer) ListInventoryItems(context.Context, *ListInventoryItemsRequest) (*ListInventoryItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInventoryItems not implemented")
}
func (UnimplementedInventoryServiceServer) UpdateInventoryLevel(context.Context, *UpdateInventoryLevelRequest) (*UpdateInventoryLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInventoryLevel not implemented")
}
func (UnimplementedInventoryServiceServer) GetInventoryStatus(context.Context, *GetInventoryStatusRequest) (*GetInventoryStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInventoryStatus not implemented")
}
func (UnimplementedInventoryServiceServer) PredictConsumption(context.Context, *PredictConsumptionRequest) (*PredictConsumptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PredictConsumption not implemented")
}
func (UnimplementedInventoryServiceServer) SetConsumptionBehavior(context.Context, *SetConsumptionBehaviorRequest) (*SetConsumptionBehaviorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConsumptionBehavior not implemented")
}
func (UnimplementedInventoryServiceServer) ConvertUnits(context.Context, *ConvertUnitsRequest) (*ConvertUnitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertUnits not implemented")
}
func (UnimplementedInventoryServiceServer) mustEmbedUnimplementedInventoryServiceServer() {}
func (UnimplementedInventoryServiceServer) testEmbeddedByValue()                          {}

// UnsafeInventoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InventoryServiceServer will
// result in compilation errors.
type UnsafeInventoryServiceServer interface {
	mustEmbedUnimplementedInventoryServiceServer()
}

func RegisterInventoryServiceServer(s grpc.ServiceRegistrar, srv InventoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedInventoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InventoryService_ServiceDesc, srv)
}

func _InventoryService_AddInventoryItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInventoryItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).AddInventoryItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_AddInventoryItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).AddInventoryItem(ctx, req.(*AddInventoryItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_GetInventoryItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInventoryItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).GetInventoryItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_GetInventoryItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).GetInventoryItem(ctx, req.(*GetInventoryItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_ListInventoryItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInventoryItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).ListInventoryItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_ListInventoryItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).ListInventoryItems(ctx, req.(*ListInventoryItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_UpdateInventoryLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInventoryLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).UpdateInventoryLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_UpdateInventoryLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).UpdateInventoryLevel(ctx, req.(*UpdateInventoryLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_GetInventoryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInventoryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).GetInventoryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_GetInventoryStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).GetInventoryStatus(ctx, req.(*GetInventoryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_PredictConsumption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PredictConsumptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).PredictConsumption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_PredictConsumption_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).PredictConsumption(ctx, req.(*PredictConsumptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_SetConsumptionBehavior_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConsumptionBehaviorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).SetConsumptionBehavior(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_SetConsumptionBehavior_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).SetConsumptionBehavior(ctx, req.(*SetConsumptionBehaviorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InventoryService_ConvertUnits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertUnitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InventoryServiceServer).ConvertUnits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InventoryService_ConvertUnits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InventoryServiceServer).ConvertUnits(ctx, req.(*ConvertUnitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InventoryService_ServiceDesc is the grpc.ServiceDesc for InventoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InventoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "inventory.v1.InventoryService",
	HandlerType: (*InventoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddInventoryItem",
			Handler:    _InventoryService_AddInventoryItem_Handler,
		},
		{
			MethodName: "GetInventoryItem",
			Handler:    _InventoryService_GetInventoryItem_Handler,
		},
		{
			MethodName: "ListInventoryItems",
			Handler:    _InventoryService_ListInventoryItems_Handler,
		},
		{
			MethodName: "UpdateInventoryLevel",
			Handler:    _InventoryService_UpdateInventoryLevel_Handler,
		},
		{
			MethodName: "GetInventoryStatus",
			Handler:    _InventoryService_GetInventoryStatus_Handler,
		},
		{
			MethodName: "PredictConsumption",
			Handler:    _InventoryService_PredictConsumption_Handler,
		},
		{
			MethodName: "SetConsumptionBehavior",
			Handler:    _InventoryService_SetConsumptionBehavior_Handler,
		},
		{
			MethodName: "ConvertUnits",
			Handler:    _InventoryService_ConvertUnits_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/inventory.proto",
}
