name: Comprehensive CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  GO_VERSION: "1.21"
  DOTNET_VERSION: "8.0"
  NODE_VERSION: "20"

jobs:
  # Job to determine which projects changed
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      go-projects: ${{ steps.changes.outputs.go-projects }}
      dotnet-projects: ${{ steps.changes.outputs.dotnet-projects }}
      proto-changed: ${{ steps.changes.outputs.proto-changed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed projects
        id: changes
        run: |
          # Get list of changed files
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          else
            # For push events, compare with previous commit
            if [[ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            else
              # For initial push, check all files (but this should rarely happen)
              CHANGED_FILES=$(git ls-files)
            fi
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Detect Go project changes (only if files in those projects changed)
          GO_PROJECTS=""
          
          # Check tasker-core
          if echo "$CHANGED_FILES" | grep -E "^tasker-core/" || echo "$CHANGED_FILES" | grep -E "^shared/" || echo "$CHANGED_FILES" | grep -E ".*\.proto$"; then
            if [[ -f "tasker-core/go.mod" ]]; then
              GO_PROJECTS="${GO_PROJECTS}tasker-core "
            fi
          fi
          
          # Check tasker-core/backend
          if echo "$CHANGED_FILES" | grep -E "^tasker-core/backend/" || echo "$CHANGED_FILES" | grep -E "^shared/" || echo "$CHANGED_FILES" | grep -E ".*\.proto$"; then
            if [[ -f "tasker-core/backend/go.mod" ]]; then
              GO_PROJECTS="${GO_PROJECTS}tasker-core/backend "
            fi
          fi
          
          # Check inventory-core
          if echo "$CHANGED_FILES" | grep -E "^inventory-core/.*\.(go|proto)$" || echo "$CHANGED_FILES" | grep -E "^shared/" || echo "$CHANGED_FILES" | grep -E "^inventory-core/go\.mod$"; then
            if [[ -f "inventory-core/go.mod" ]]; then
              GO_PROJECTS="${GO_PROJECTS}inventory-core "
            fi
          fi
          
          # Check inventory-core/backend
          if echo "$CHANGED_FILES" | grep -E "^inventory-core/backend/" || echo "$CHANGED_FILES" | grep -E "^shared/" || echo "$CHANGED_FILES" | grep -E ".*\.proto$"; then
            if [[ -f "inventory-core/backend/go.mod" ]]; then
              GO_PROJECTS="${GO_PROJECTS}inventory-core/backend "
            fi
          fi
          
          # Check shared
          if echo "$CHANGED_FILES" | grep -E "^shared/"; then
            if [[ -f "shared/go.mod" ]]; then
              GO_PROJECTS="${GO_PROJECTS}shared "
            fi
          fi
          
          # Check home-manager/backend
          if echo "$CHANGED_FILES" | grep -E "^home-manager/" || echo "$CHANGED_FILES" | grep -E "^shared/" || echo "$CHANGED_FILES" | grep -E ".*\.proto$"; then
            if [[ -f "home-manager/backend/go.mod" ]]; then
              GO_PROJECTS="${GO_PROJECTS}home-manager/backend "
            fi
          fi

          # Detect .NET project changes
          DOTNET_PROJECTS=""
          if echo "$CHANGED_FILES" | grep -E "^inventory-core/frontend/"; then
            if [[ -f "inventory-core/frontend/InventoryClient.sln" ]]; then
              DOTNET_PROJECTS="${DOTNET_PROJECTS}inventory-core/frontend "
            fi
          fi

          # Detect proto changes
          PROTO_CHANGED="false"
          if echo "$CHANGED_FILES" | grep -E ".*\.proto$"; then
            PROTO_CHANGED="true"
          fi

          echo "go-projects=${GO_PROJECTS}" >> $GITHUB_OUTPUT
          echo "dotnet-projects=${DOTNET_PROJECTS}" >> $GITHUB_OUTPUT  
          echo "proto-changed=${PROTO_CHANGED}" >> $GITHUB_OUTPUT

  # Setup protobuf generation (shared across projects)
  setup-proto:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.proto-changed == 'true' || needs.detect-changes.outputs.go-projects != ''
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache protoc and Go modules
        uses: actions/cache@v4
        with:
          path: |
            /usr/bin/protoc
            ~/.cache/go-build
            ~/go/pkg/mod
            ~/go/bin
          key: ${{ runner.os }}-proto-${{ hashFiles('**/go.sum', '**/buf.gen.yaml', '**/buf.yaml') }}-v2
          restore-keys: |
            ${{ runner.os }}-proto-

      - name: Install protoc and buf
        run: |
          # Install protoc
          sudo apt-get update
          sudo apt-get install -y protobuf-compiler

          # Install Go protobuf plugins
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

          # Install buf
          curl -sSL "https://github.com/bufbuild/buf/releases/latest/download/buf-Linux-x86_64" -o "/usr/local/bin/buf"
          chmod +x "/usr/local/bin/buf"

      - name: Generate protobuf code for all projects
        run: |
          echo "$HOME/go/bin" >> $GITHUB_PATH

          # Function to generate protobuf with standardized paths
          generate_proto() {
            local project=$1
            local service=$2
            local proto_files=$3
            
            echo "Generating protobuf for $project ($service)..."
            cd "$project"
            
            # Create standardized directory structure
            mkdir -p "pkg/proto/$service/v1" 2>/dev/null || true
            
            # Check if proto files exist
            local files_exist=false
            for file in "${proto_files[@]}"; do
              if [[ -f "$file" ]]; then
                files_exist=true
                break
              fi
            done
            
            if [[ "$files_exist" == "false" ]]; then
              echo "No proto files found for $project, skipping..."
              cd ..
              return
            fi
            
            # Generate Go protobuf files
            echo "  Running protoc for Go: ${proto_files[*]}..."
            protoc --go_out=pkg/proto --go_opt=paths=source_relative \
                   --go-grpc_out=pkg/proto --go-grpc_opt=paths=source_relative \
                   --proto_path=proto \
                   "${proto_files[@]}" || { echo "Protoc generation failed for $project, continuing..."; cd ..; return; }
            
            # Move files to standardized v1 directory
            find pkg/proto -name "*.pb.go" -not -path "*/v1/*" | while read file; do
              mv "$file" "pkg/proto/$service/v1/"
            done
            
            cd ..
          }

          # Generate for tasker-core
          if [[ -f "tasker-core/proto/task.proto" ]]; then
            generate_proto "tasker-core" "taskcore" "proto/task.proto"
          fi

          # Generate for inventory-core
          if [[ -f "inventory-core/proto/inventory.proto" ]]; then
            generate_proto "inventory-core" "inventory" "proto/inventory.proto"
          fi

          # Generate for shared
          if [[ -f "shared/proto/events.proto" ]]; then
            generate_proto "shared" "events" "proto/events.proto"
          fi

          # Generate for home-manager (has multiple proto files)
          if [[ -f "home-manager/proto/config.proto" ]]; then
            cd home-manager
            mkdir -p "backend/pkg/proto/hometasker/v1" 2>/dev/null || true
            protoc --go_out=backend/pkg/proto --go_opt=paths=source_relative \
                   --go-grpc_out=backend/pkg/proto --go-grpc_opt=paths=source_relative \
                   --proto_path=proto \
                   proto/config.proto proto/cooking.proto proto/hometasker_service.proto proto/state.proto proto/tasks.proto || echo "Protoc generation failed for home-manager, continuing..."
            find backend/pkg/proto -name "*.pb.go" -not -path "*/v1/*" | while read file; do
              mv "$file" "backend/pkg/proto/hometasker/v1/"
            done
            
            if [[ "$proto_files_exist" == "true" ]]; then
              protoc --go_out=backend/pkg/proto --go_opt=paths=source_relative \
                     --go-grpc_out=backend/pkg/proto --go-grpc_opt=paths=source_relative \
                     --proto_path=proto \
                     proto/config.proto proto/cooking.proto proto/hometasker_service.proto proto/state.proto proto/tasks.proto || echo "Protoc generation failed for home-manager, continuing..."
              
              # Move files to standardized v1 directory
              find backend/pkg/proto -name "*.pb.go" -not -path "*/v1/*" 2>/dev/null | while read -r file; do
                if [[ -f "$file" ]]; then
                  mv "$file" "backend/pkg/proto/hometasker/v1/"
                fi
              done
              
              echo "  ✓ Generated protobuf files for home-manager"
            else
              echo "Some proto files missing for home-manager, skipping..."
            fi
            
            cd ..
          fi

          echo ""
          echo "✓ Protobuf generation complete!"
          echo "Generated files structure:"
          echo "  tasker-core/pkg/proto/taskcore/v1/*.pb.go"
          echo "  inventory-core/pkg/proto/inventory/v1/*.pb.go"  
          echo "  shared/pkg/proto/events/v1/*.pb.go"
          echo "  home-manager/backend/pkg/proto/hometasker/v1/*.pb.go"

      - name: Upload proto artifacts
        uses: actions/upload-artifact@v4
        with:
          name: proto-generated
          path: |
            **/**.pb.go
            **/goproto/**
          retention-days: 1

  # Test each Go project separately
  test-go-projects:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-proto]
    if: needs.detect-changes.outputs.go-projects != ''
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJson('["tasker-core", "tasker-core/backend", "inventory-core", "inventory-core/backend", "shared", "home-manager/backend"]') }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download proto artifacts
        uses: actions/download-artifact@v4
        with:
          name: proto-generated
          path: .

      - name: Cache Go modules for ${{ matrix.project }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.project }}-${{ hashFiles(format('{0}/go.sum', matrix.project), format('{0}/go.mod', matrix.project)) }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.project }}-

      - name: Check if project exists
        id: check-project
        run: |
          if [[ -f "${{ matrix.project }}/go.mod" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies and tidy for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          # Handle local module replacements
          go mod edit -replace=github.com/DaDevFox/task-systems/inventory-core=../inventory-core || true
          go mod edit -replace=github.com/DaDevFox/task-systems/shared=../shared || true  
          go mod edit -replace=github.com/DaDevFox/task-systems/task-core=../tasker-core || true
          go mod edit -replace=github.com/DaDevFox/task-systems/tasker-core=../tasker-core || true

          # For nested backend modules, adjust paths
          if [[ "${{ matrix.project }}" == *"/backend" ]]; then
            go mod edit -replace=github.com/DaDevFox/task-systems/inventory-core=../../inventory-core || true
            go mod edit -replace=github.com/DaDevFox/task-systems/shared=../../shared || true
            go mod edit -replace=github.com/DaDevFox/task-systems/task-core=../../tasker-core || true  
            go mod edit -replace=github.com/DaDevFox/task-systems/tasker-core=../../tasker-core || true
          fi

          go mod download
          go mod tidy

      - name: Run tests for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Generate coverage reports for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          if [[ -f coverage.out ]]; then
            go tool cover -html=coverage.out -o coverage.html
            go tool cover -func=coverage.out > coverage_functions.txt
            echo "Coverage for ${{ matrix.project }}:"
            go tool cover -func=coverage.out | tail -1
          fi

      - name: Run linters for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          go vet ./...
          # Check formatting
          unformatted=$(go fmt ./...)
          if [[ -n "$unformatted" ]]; then
            echo "Code is not formatted. Please run 'go fmt ./...'"
            echo "Unformatted files: $unformatted"
            exit 1
          fi

      - name: Build project ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          # Try to build any binaries
          if [[ -d "cmd" ]]; then
            for cmd_dir in cmd/*/; do
              if [[ -d "$cmd_dir" ]]; then
                cmd_name=$(basename "$cmd_dir")
                echo "Building $cmd_name..."
                go build -o "bin/$cmd_name" "./$cmd_dir" || echo "Failed to build $cmd_name, continuing..."
              fi
            done
          else
            # Try to build the module
            go build ./... || echo "No buildable packages found, continuing..."
          fi

      - name: Upload coverage artifacts for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.project }}-${{ github.run_number }}
          path: |
            ${{ matrix.project }}/coverage.out
            ${{ matrix.project }}/coverage.html
            ${{ matrix.project }}/coverage_functions.txt
          retention-days: 30

      - name: Upload binaries for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.project }}-${{ github.run_number }}
          path: ${{ matrix.project }}/bin/*
          retention-days: 7

  # Test .NET projects
  test-dotnet-projects:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-proto, test-go-projects]
    if: needs.detect-changes.outputs.dotnet-projects != ''
    strategy:
      fail-fast: false
      matrix:
        project: ["inventory-core/frontend"]
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Download Go binaries (needed for integration tests)
        uses: actions/download-artifact@v4
        with:
          name: binaries-inventory-core/backend-${{ github.run_number }}
          path: inventory-core/backend/bin
        continue-on-error: true

      - name: Make binaries executable
        run: |
          if [[ -d "inventory-core/backend/bin" ]]; then
            chmod +x inventory-core/backend/bin/* || true
          fi

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore dependencies for ${{ matrix.project }}
        working-directory: ${{ matrix.project }}
        run: dotnet restore

      - name: Build ${{ matrix.project }}
        working-directory: ${{ matrix.project }}
        run: dotnet build --no-restore --configuration Release

      - name: Run unit tests for ${{ matrix.project }}
        working-directory: ${{ matrix.project }}
        run: |
          # Run only unit tests (exclude integration tests that need backend)
          dotnet test --no-build --configuration Release \
            --filter "FullyQualifiedName!~IntegrationTests" \
            --logger trx --results-directory TestResults/ \
            --collect:"XPlat Code Coverage" || echo "Unit tests failed, continuing with integration tests..."

      - name: Run integration tests for ${{ matrix.project }}
        working-directory: ${{ matrix.project }}
        run: |
          # Run integration tests separately with better error handling
          dotnet test --no-build --configuration Release \
            --filter "FullyQualifiedName~IntegrationTests" \
            --logger trx --results-directory TestResults/ \
            --collect:"XPlat Code Coverage" || echo "Integration tests failed (expected without proper backend setup)"

      - name: Upload test results for ${{ matrix.project }}
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.project }}-${{ github.run_number }}
          path: |
            ${{ matrix.project }}/TestResults/**/*.trx
            ${{ matrix.project }}/TestResults/**/*.xml
          retention-days: 30

  # Security scanning for Go projects
  security-scan:
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-proto]
    if: needs.detect-changes.outputs.go-projects != ''
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJson('["tasker-core", "inventory-core", "home-manager/backend"]') }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download proto artifacts
        uses: actions/download-artifact@v4
        with:
          name: proto-generated
          path: .

      - name: Check if project exists
        id: check-project
        run: |
          if [[ -f "${{ matrix.project }}/go.mod" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        working-directory: ${{ matrix.project }}
        run: |
          # Handle local module replacements
          go mod edit -replace=github.com/DaDevFox/task-systems/inventory-core=../inventory-core || true
          go mod edit -replace=github.com/DaDevFox/task-systems/shared=../shared || true
          go mod edit -replace=github.com/DaDevFox/task-systems/task-core=../tasker-core || true
          go mod edit -replace=github.com/DaDevFox/task-systems/tasker-core=../tasker-core || true

          if [[ "${{ matrix.project }}" == *"/backend" ]]; then
            go mod edit -replace=github.com/DaDevFox/task-systems/inventory-core=../../inventory-core || true
            go mod edit -replace=github.com/DaDevFox/task-systems/shared=../../shared || true
            go mod edit -replace=github.com/DaDevFox/task-systems/task-core=../../tasker-core || true
            go mod edit -replace=github.com/DaDevFox/task-systems/tasker-core=../../tasker-core || true
          fi

          go mod download
          go mod tidy

      - name: Run Gosec Security Scanner for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        uses: securego/gosec@master
        with:
          args: "-fmt sarif -out gosec-${{ matrix.project }}.sarif -quiet -no-fail ./${{ matrix.project }}/..."
        continue-on-error: true

      - name: Upload SARIF file for ${{ matrix.project }}
        if: steps.check-project.outputs.exists == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec-${{ matrix.project }}.sarif
        continue-on-error: true

  # Code Climate analysis for cognitive complexity
  code-quality-analysis:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Code Climate Test Reporter
        run: |
          curl -L https://codeclimate.com/downloads/test-reporter/test-reporter-latest-linux-amd64 > ./cc-test-reporter
          chmod +x ./cc-test-reporter

      - name: Download all coverage reports
        uses: actions/download-artifact@v4
        with:
          path: coverage-reports/
        continue-on-error: true

      - name: Setup Code Climate configuration
        run: |
          cat > .codeclimate.yml << 'EOF'
          version: "2"

          checks:
            # Enable cognitive complexity checking
            method-complexity:
              config:
                threshold: 15
            argument-count:
              config:
                threshold: 4
            complex-logic:
              config:
                threshold: 4
            file-lines:
              config:
                threshold: 250
            method-count:
              config:
                threshold: 20
            method-lines:
              config:
                threshold: 25
            nested-control-flow:
              config:
                threshold: 4
            return-statements:
              config:
                threshold: 4
            similar-code:
              config:
                threshold: # language defaults
            identical-code:
              config:
                threshold: # language defaults

          plugins:
            # Go static analysis
            gofmt:
              enabled: true
            govet:
              enabled: true
            golint:
              enabled: true
            
            # Generic duplication detection  
            duplication:
              enabled: true
              config:
                languages:
                  go:
                    mass_threshold: 30
                  csharp:
                    mass_threshold: 30

          exclude_patterns:
            - "coverage/"
            - "**/*_test.go"
            - "**/*.pb.go"
            - "**/goproto/**"
            - "TestResults/"
            - "bin/"
            - "obj/"
          EOF

      - name: Run Code Climate Analysis
        run: |
          # Run Code Climate analysis for cognitive complexity
          ./cc-test-reporter analyze --dev || echo "Code Climate analysis completed with issues"

      - name: Generate cognitive complexity report
        run: |
          # Create a simple cognitive complexity analysis using gocyclo for Go files
          if command -v go &> /dev/null; then
            echo "Installing gocyclo for Go complexity analysis..."
            go install github.com/fzipp/gocyclo/cmd/gocyclo@latest || echo "Failed to install gocyclo"
            
            # Find high complexity functions in Go files
            echo "# 🧠 Cognitive Complexity Report" > complexity_report.md
            echo "" >> complexity_report.md
            echo "Functions with cognitive complexity >= 15:" >> complexity_report.md
            echo "" >> complexity_report.md
            
            HIGH_COMPLEXITY_FOUND=false
            
            for go_file in $(find . -name "*.go" -not -path "*/vendor/*" -not -name "*_test.go" -not -name "*.pb.go"); do
              if [[ -f "$go_file" ]]; then
                complexity_output=$(~/go/bin/gocyclo -over 14 "$go_file" 2>/dev/null || echo "")
                if [[ -n "$complexity_output" ]]; then
                  echo "### $(basename $go_file)" >> complexity_report.md
                  echo '```' >> complexity_report.md
                  echo "$complexity_output" >> complexity_report.md
                  echo '```' >> complexity_report.md
                  echo "" >> complexity_report.md
                  HIGH_COMPLEXITY_FOUND=true
                fi
              fi
            done
            
            if [[ "$HIGH_COMPLEXITY_FOUND" == "false" ]]; then
              echo "✅ No functions found with cognitive complexity >= 15" >> complexity_report.md
            else
              echo "" >> complexity_report.md
              echo "---" >> complexity_report.md
              echo "**Recommendations:**" >> complexity_report.md
              echo "- 🟡 **Moderate (15-20)**: Consider refactoring if adding features" >> complexity_report.md
              echo "- 🟠 **High (21-30)**: Should be refactored for better maintainability" >> complexity_report.md
              echo "- 🔴 **Very High (31+)**: Critical - requires immediate attention" >> complexity_report.md
              echo "" >> complexity_report.md
              echo "Functions above 15 cognitive complexity may benefit from being broken down into smaller, more focused functions following the single-responsibility principle." >> complexity_report.md
            fi
          fi

      - name: Comment cognitive complexity results on PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let complexityReport = '';
            try {
              complexityReport = fs.readFileSync('complexity_report.md', 'utf8');
            } catch (error) {
              complexityReport = '# 🧠 Cognitive Complexity Report\n\n⚠️ Could not generate complexity report.';
            }

            // Check if we should post the report (only if high complexity functions found)
            if (complexityReport.includes('No functions found with cognitive complexity')) {
              console.log('No high complexity functions found, skipping comment.');
              return;
            }

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(comment => 
              comment.body.includes('🧠 Cognitive Complexity Report')
            );

            const commentBody = complexityReport;

            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }

      - name: Upload Code Climate artifacts
        uses: actions/upload-artifact@v4
        with:
          name: code-climate-report-${{ github.run_number }}
          path: |
            .codeclimate.yml
            complexity_report.md
          retention-days: 30

  # Aggregate results and report
  aggregate-results:
    runs-on: ubuntu-latest
    needs: [test-go-projects, test-dotnet-projects, security-scan]
    if: always()
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-results/

      - name: Generate summary report
        run: |
          echo "# 📊 CI/CD Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🐹 Go Projects" >> $GITHUB_STEP_SUMMARY

          # Check Go project results
          for project in "tasker-core" "tasker-core/backend" "inventory-core" "inventory-core/backend" "shared" "home-manager/backend"; do
            if [[ -d "all-results/coverage-$project-${{ github.run_number }}" ]]; then
              echo "- ✅ **$project**: Tests completed successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "- ❌ **$project**: Tests failed or skipped" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🔷 .NET Projects" >> $GITHUB_STEP_SUMMARY

          if [[ -d "all-results/test-results-inventory-core/frontend-${{ github.run_number }}" ]]; then
            echo "- ✅ **inventory-core/frontend**: Tests completed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ❌ **inventory-core/frontend**: Tests failed or skipped" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 🔒 Security Scanning" >> $GITHUB_STEP_SUMMARY
          echo "Security scans completed for all applicable Go projects." >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## 📈 Coverage Reports" >> $GITHUB_STEP_SUMMARY
          echo "Coverage reports have been uploaded as artifacts and are available for download." >> $GITHUB_STEP_SUMMARY

      - name: Check overall success
        run: |
          # This job will succeed if any of the test jobs succeeded
          if [[ "${{ needs.test-go-projects.result }}" == "success" ]] || [[ "${{ needs.test-dotnet-projects.result }}" == "success" ]]; then
            echo "At least one test suite passed successfully"
            exit 0
          elif [[ "${{ needs.test-go-projects.result }}" == "skipped" ]] && [[ "${{ needs.test-dotnet-projects.result }}" == "skipped" ]]; then
            echo "All tests were skipped (no changes detected)"  
            exit 0
          else
            echo "All test suites failed"
            exit 1
          fi
