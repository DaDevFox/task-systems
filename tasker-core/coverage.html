
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/DaDevFox/task-systems/task-core/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/DaDevFox/task-systems/task-core/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/DaDevFox/task-systems/task-core/internal/calendar/calendar_service.go (0.0%)</option>
				
				<option value="file3">github.com/DaDevFox/task-systems/task-core/internal/domain/task.go (69.8%)</option>
				
				<option value="file4">github.com/DaDevFox/task-systems/task-core/internal/email/email_service.go (0.0%)</option>
				
				<option value="file5">github.com/DaDevFox/task-systems/task-core/internal/grpc/task_server.go (35.8%)</option>
				
				<option value="file6">github.com/DaDevFox/task-systems/task-core/internal/repository/memory_repository.go (51.7%)</option>
				
				<option value="file7">github.com/DaDevFox/task-systems/task-core/internal/service/task_service.go (58.5%)</option>
				
				<option value="file8">github.com/DaDevFox/task-systems/task-core/proto/taskcore/v1/task.pb.go (0.0%)</option>
				
				<option value="file9">github.com/DaDevFox/task-systems/task-core/proto/taskcore/v1/task_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "strings"
        "time"

        "github.com/ktr0731/go-fuzzyfinder"
        "github.com/spf13/cobra"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        pb "github.com/DaDevFox/task-systems/task-core/proto/taskcore/v1"
)

var (
        serverAddr string
        client     pb.TaskServiceClient
        conn       *grpc.ClientConn
)

func main() <span class="cov0" title="0">{
        var rootCmd = &amp;cobra.Command{
                Use:   "tasker",
                Short: "Task management CLI client",
                Long:  "A comprehensive task management CLI client with advanced features",
                PersistentPreRun: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        // Connect to server
                        var err error
                        conn, err = grpc.Dial(serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to connect to server: %v", err)
                        }</span>
                        <span class="cov0" title="0">client = pb.NewTaskServiceClient(conn)</span>
                },
                PersistentPostRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        if conn != nil </span><span class="cov0" title="0">{
                                conn.Close()
                        }</span>
                },
        }

        // Global flags
        <span class="cov0" title="0">rootCmd.PersistentFlags().StringVar(&amp;serverAddr, "server", "localhost:8080", "Server address")

        // Add commands
        rootCmd.AddCommand(newAddCommand())
        rootCmd.AddCommand(newListCommand())
        rootCmd.AddCommand(newGetCommand())
        rootCmd.AddCommand(newStartCommand())
        rootCmd.AddCommand(newStopCommand())
        rootCmd.AddCommand(newCompleteCommand())
        rootCmd.AddCommand(newStageCommand())
        rootCmd.AddCommand(newTagCommand())
        rootCmd.AddCommand(newUserCommand())
        rootCmd.AddCommand(newSyncCommand())

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func newAddCommand() *cobra.Command <span class="cov0" title="0">{
        var description string

        cmd := &amp;cobra.Command{
                Use:   "add &lt;task-name&gt;",
                Short: "Add a new task",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        name := args[0]

                        req := &amp;pb.AddTaskRequest{
                                Name:        name,
                                Description: description,
                        }

                        resp, err := client.AddTask(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("AddTask failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Created task: %s (ID: %s)\n", resp.Task.Name, resp.Task.Id)</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;description, "description", "d", "", "Task description")

        return cmd</span>
}

func newListCommand() *cobra.Command <span class="cov0" title="0">{
        var stage string

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List tasks",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        stageEnum := parseStage(stage)
                        req := &amp;pb.ListTasksRequest{
                                Stage: stageEnum,
                        }

                        resp, err := client.ListTasks(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("ListTasks failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Tasks (%d total):\n", len(resp.Tasks))
                        for _, task := range resp.Tasks </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s - %s [%s]\n", task.Id, task.Name, task.Description, task.Stage.String())
                        }</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;stage, "stage", "s", "pending", "Task stage (pending, staging, active, completed)")

        return cmd</span>
}

func newGetCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "get &lt;task-id&gt;",
                Short: "Get task details",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        taskID := args[0]
                        req := &amp;pb.GetTaskRequest{Id: taskID}

                        resp, err := client.GetTask(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("GetTask failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">printTaskDetails(resp.Task)</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

func newStartCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "start [task-id]",
                Short: "Start a task (with fuzzy picker if no ID provided)",
                Args:  cobra.MaximumNArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        var taskID string
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                // Use fuzzy picker to select task
                                var err error
                                taskID, err = fuzzySelectTask(ctx, pb.TaskStage_STAGE_STAGING)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatalf("Task selection failed: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                taskID = args[0]
                        }</span>

                        <span class="cov0" title="0">req := &amp;pb.StartTaskRequest{Id: taskID}
                        resp, err := client.StartTask(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("StartTask failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Started task: %s\n", resp.Task.Name)</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

func newStopCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "stop [task-id]",
                Short: "Stop a task (with fuzzy picker if no ID provided)",
                Args:  cobra.MaximumNArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        var taskID string
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                // Use fuzzy picker to select task
                                var err error
                                taskID, err = fuzzySelectTask(ctx, pb.TaskStage_STAGE_ACTIVE)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatalf("Task selection failed: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                taskID = args[0]
                        }</span>

                        <span class="cov0" title="0">req := &amp;pb.StopTaskRequest{Id: taskID}
                        resp, err := client.StopTask(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("StopTask failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Stopped task: %s (Completed: %t)\n", resp.Task.Name, resp.Completed)</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

func newCompleteCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "complete [task-id]",
                Short: "Complete a task (with fuzzy picker if no ID provided)",
                Args:  cobra.MaximumNArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        var taskID string
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                // Use fuzzy picker to select task
                                var err error
                                taskID, err = fuzzySelectTask(ctx, pb.TaskStage_STAGE_ACTIVE)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatalf("Task selection failed: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                taskID = args[0]
                        }</span>

                        <span class="cov0" title="0">req := &amp;pb.CompleteTaskRequest{Id: taskID}
                        resp, err := client.CompleteTask(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("CompleteTask failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Completed task: %s\n", resp.Task.Name)</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

func newStageCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "stage",
                Short: "Stage management commands",
        }

        cmd.AddCommand(&amp;cobra.Command{
                Use:   "move &lt;task-id&gt;",
                Short: "Move task to staging",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        taskID := args[0]
                        req := &amp;pb.MoveToStagingRequest{SourceId: taskID}

                        resp, err := client.MoveToStaging(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("MoveToStaging failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Moved task to staging: %s\n", resp.Task.Name)</span>
                },
        })

        <span class="cov0" title="0">return cmd</span>
}

func newTagCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "tag",
                Short: "Tag management commands",
        }

        cmd.AddCommand(&amp;cobra.Command{
                Use:   "update &lt;task-id&gt;",
                Short: "Update task tags (shows current tags)",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        taskID := args[0]

                        // Get current task to show existing tags
                        getReq := &amp;pb.GetTaskRequest{Id: taskID}
                        getResp, err := client.GetTask(ctx, getReq)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to get task: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Current tags for task '%s':\n", getResp.Task.Name)
                        for key, value := range getResp.Task.Tags </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s\n", key, value.String())
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("\nTo update tags, use the UpdateTaskTags RPC directly\n")</span>
                },
        })

        <span class="cov0" title="0">return cmd</span>
}

func newUserCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "user",
                Short: "User management commands",
        }

        cmd.AddCommand(&amp;cobra.Command{
                Use:   "get &lt;user-id&gt;",
                Short: "Get user details",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()

                        userID := args[0]
                        req := &amp;pb.GetUserRequest{UserId: userID}

                        resp, err := client.GetUser(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("GetUser failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("User: %s (%s)\n", resp.User.Name, resp.User.Email)
                        fmt.Printf("ID: %s\n", resp.User.Id)
                        if len(resp.User.NotificationSettings) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("Notification Settings:\n")
                                for _, setting := range resp.User.NotificationSettings </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s: %s\n", setting.Type.String(), setting.String())
                                }</span>
                        }
                },
        })

        <span class="cov0" title="0">return cmd</span>
}

func newSyncCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "sync &lt;user-id&gt;",
                Short: "Sync tasks with Google Calendar",
                Args:  cobra.ExactArgs(1),
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                        defer cancel()

                        userID := args[0]
                        req := &amp;pb.SyncCalendarRequest{UserId: userID}

                        resp, err := client.SyncCalendar(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("SyncCalendar failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Calendar sync completed for user %s\n", userID)
                        fmt.Printf("Sync response: %s\n", resp.String())</span>
                },
        }

        <span class="cov0" title="0">return cmd</span>
}

// Helper functions

func fuzzySelectTask(ctx context.Context, stage pb.TaskStage) (string, error) <span class="cov0" title="0">{
        req := &amp;pb.ListTasksRequest{Stage: stage}
        resp, err := client.ListTasks(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(resp.Tasks) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no tasks found in %s stage", stage.String())
        }</span>

        <span class="cov0" title="0">idx, err := fuzzyfinder.Find(
                resp.Tasks,
                func(i int) string </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s: %s", resp.Tasks[i].Id, resp.Tasks[i].Name)
                }</span>,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return resp.Tasks[idx].Id, nil</span>
}

func parseStage(stageStr string) pb.TaskStage <span class="cov0" title="0">{
        switch strings.ToLower(stageStr) </span>{
        case "inbox":<span class="cov0" title="0">
                return pb.TaskStage_STAGE_INBOX</span>
        case "pending":<span class="cov0" title="0">
                return pb.TaskStage_STAGE_PENDING</span>
        case "staging":<span class="cov0" title="0">
                return pb.TaskStage_STAGE_STAGING</span>
        case "active":<span class="cov0" title="0">
                return pb.TaskStage_STAGE_ACTIVE</span>
        case "completed":<span class="cov0" title="0">
                // Map to archived for now since COMPLETED doesn't exist in enum
                return pb.TaskStage_STAGE_ARCHIVED</span>
        default:<span class="cov0" title="0">
                return pb.TaskStage_STAGE_PENDING</span>
        }
}

func printTaskDetails(task *pb.Task) <span class="cov0" title="0">{
        fmt.Printf("Task: %s\n", task.Name)
        fmt.Printf("ID: %s\n", task.Id)
        fmt.Printf("Description: %s\n", task.Description)
        fmt.Printf("Stage: %s\n", task.Stage.String())
        if task.Status != nil </span><span class="cov0" title="0">{
                fmt.Printf("Status: %s\n", task.Status.String())
        }</span>
        <span class="cov0" title="0">fmt.Printf("User ID: %s\n", task.UserId)

        if len(task.Location) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Location: %s\n", strings.Join(task.Location, " &gt; "))
        }</span>

        <span class="cov0" title="0">if len(task.Tags) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Tags:\n")
                for key, value := range task.Tags </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: %s\n", key, value.String())
                }</span>
        }

        <span class="cov0" title="0">if len(task.Inflows) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Dependencies: %s\n", strings.Join(task.Inflows, ", "))
        }</span>

        <span class="cov0" title="0">if len(task.Outflows) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Dependents: %s\n", strings.Join(task.Outflows, ", "))
        }</span>

        <span class="cov0" title="0">if task.GoogleCalendarEventId != "" </span><span class="cov0" title="0">{
                fmt.Printf("Calendar Event ID: %s\n", task.GoogleCalendarEventId)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        "github.com/DaDevFox/task-systems/task-core/internal/calendar"
        "github.com/DaDevFox/task-systems/task-core/internal/email"
        grpcserver "github.com/DaDevFox/task-systems/task-core/internal/grpc"
        "github.com/DaDevFox/task-systems/task-core/internal/repository"
        "github.com/DaDevFox/task-systems/task-core/internal/service"
        pb "github.com/DaDevFox/task-systems/task-core/proto/taskcore/v1"
)

func main() <span class="cov0" title="0">{
        var (
                port                     = flag.Int("port", 8080, "The server port")
                maxInboxSize             = flag.Int("max-inbox-size", 5, "Maximum number of tasks allowed in inbox")
                enableCalendarSync       = flag.Bool("enable-calendar", false, "Enable Google Calendar integration")
                enableEmailNotifications = flag.Bool("enable-email", false, "Enable email notifications")
                calendarClientID         = flag.String("calendar-client-id", "", "Google Calendar OAuth2 client ID")
                calendarClientSecret     = flag.String("calendar-client-secret", "", "Google Calendar OAuth2 client secret")
                calendarRedirectURL      = flag.String("calendar-redirect-url", "http://localhost:8080/auth/callback", "Calendar OAuth2 redirect URL")
                smtpHost                 = flag.String("smtp-host", "smtp.gmail.com", "SMTP server host")
                smtpPort                 = flag.String("smtp-port", "587", "SMTP server port")
                smtpUsername             = flag.String("smtp-username", "", "SMTP username")
                smtpPassword             = flag.String("smtp-password", "", "SMTP password")
                fromEmail                = flag.String("from-email", "", "From email address")
                reminderInterval         = flag.Duration("reminder-interval", 1*time.Hour, "Interval for checking due reminders")
        )
        flag.Parse()

        // Create repositories
        taskRepo := repository.NewInMemoryTaskRepository()
        userRepo := repository.NewInMemoryUserRepository()

        // Initialize services (optional)
        var calendarService *calendar.CalendarService
        var emailService *email.EmailService

        if *enableCalendarSync </span><span class="cov0" title="0">{
                if *calendarClientID == "" || *calendarClientSecret == "" </span><span class="cov0" title="0">{
                        log.Fatal("Calendar client ID and secret are required when calendar sync is enabled")
                }</span>
                <span class="cov0" title="0">calendarService = calendar.NewCalendarService(*calendarClientID, *calendarClientSecret, *calendarRedirectURL)
                log.Println("Calendar sync enabled")</span>
        }

        <span class="cov0" title="0">if *enableEmailNotifications </span><span class="cov0" title="0">{
                if *smtpUsername == "" || *smtpPassword == "" || *fromEmail == "" </span><span class="cov0" title="0">{
                        log.Fatal("SMTP credentials and from email are required when email notifications are enabled")
                }</span>
                <span class="cov0" title="0">emailService = email.NewEmailService(*smtpHost, *smtpPort, *smtpUsername, *smtpPassword, *fromEmail)
                log.Println("Email notifications enabled")</span>
        }

        // Create unified task service with all features
        <span class="cov0" title="0">taskService := service.NewTaskService(
                taskRepo,
                *maxInboxSize,
                userRepo,
                calendarService,
                emailService,
        )

        // Create gRPC server
        taskServer := grpcserver.NewTaskServer(taskService)

        // Set up gRPC server
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">s := grpc.NewServer()
        pb.RegisterTaskServiceServer(s, taskServer)

        // Enable reflection for easier debugging
        reflection.Register(s)

        // Start reminder check routine if email service is enabled
        if emailService != nil </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        ticker := time.NewTicker(*reminderInterval)
                        defer ticker.Stop()
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ticker.C:<span class="cov0" title="0">
                                        if err := taskService.CheckDueReminders(context.Background()); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error checking due reminders: %v", err)
                                        }</span>
                                }
                        }
                }()
                <span class="cov0" title="0">log.Printf("Started reminder check routine (interval: %v)", *reminderInterval)</span>
        }

        // Set up graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        go func() </span><span class="cov0" title="0">{
                sigChan := make(chan os.Signal, 1)
                signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
                &lt;-sigChan

                log.Println("Shutting down server...")
                s.GracefulStop()
                cancel()
        }</span>()

        <span class="cov0" title="0">log.Printf("Task service starting on port %d", *port)
        log.Printf("Max inbox size: %d", *maxInboxSize)

        if err := s.Serve(lis); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to serve: %v", err)
        }</span>

        <span class="cov0" title="0">&lt;-ctx.Done()
        log.Println("Server stopped")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package calendar

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"
        "google.golang.org/api/calendar/v3"
        "google.golang.org/api/option"

        "github.com/DaDevFox/task-systems/task-core/internal/domain"
)

// CalendarService handles Google Calendar integration
type CalendarService struct {
        config *oauth2.Config
}

// NewCalendarService creates a new calendar service
func NewCalendarService(clientID, clientSecret, redirectURL string) *CalendarService <span class="cov0" title="0">{
        config := &amp;oauth2.Config{
                ClientID:     clientID,
                ClientSecret: clientSecret,
                RedirectURL:  redirectURL,
                Scopes:       []string{calendar.CalendarScope},
                Endpoint:     google.Endpoint,
        }

        return &amp;CalendarService{
                config: config,
        }
}</span>

// GetAuthURL returns the URL for OAuth2 authorization
func (cs *CalendarService) GetAuthURL(state string) string <span class="cov0" title="0">{
        return cs.config.AuthCodeURL(state, oauth2.AccessTypeOffline)
}</span>

// ExchangeCodeForToken exchanges authorization code for access token
func (cs *CalendarService) ExchangeCodeForToken(ctx context.Context, code string) (*oauth2.Token, error) <span class="cov0" title="0">{
        return cs.config.Exchange(ctx, code)
}</span>

// TokenFromJSON creates a token from JSON string
func (cs *CalendarService) TokenFromJSON(jsonStr string) (*oauth2.Token, error) <span class="cov0" title="0">{
        var token oauth2.Token
        err := json.Unmarshal([]byte(jsonStr), &amp;token)
        return &amp;token, err
}</span>

// TokenToJSON converts token to JSON string
func (cs *CalendarService) TokenToJSON(token *oauth2.Token) (string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(token)
        return string(data), err
}</span>

// CreateOrUpdateEvent creates or updates a calendar event for a task
func (cs *CalendarService) CreateOrUpdateEvent(ctx context.Context, token *oauth2.Token, task *domain.Task, userEmail string) (string, error) <span class="cov0" title="0">{
        client := cs.config.Client(ctx, token)
        service, err := calendar.NewService(ctx, option.WithHTTPClient(client))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create calendar service: %w", err)
        }</span>

        <span class="cov0" title="0">event := cs.taskToCalendarEvent(task, userEmail)

        if task.GoogleCalendarEventID != "" </span><span class="cov0" title="0">{
                // Update existing event
                updatedEvent, err := service.Events.Update("primary", task.GoogleCalendarEventID, event).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to update calendar event: %w", err)
                }</span>
                <span class="cov0" title="0">return updatedEvent.Id, nil</span>
        } else<span class="cov0" title="0"> {
                // Create new event
                createdEvent, err := service.Events.Insert("primary", event).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create calendar event: %w", err)
                }</span>
                <span class="cov0" title="0">return createdEvent.Id, nil</span>
        }
}

// DeleteEvent deletes a calendar event
func (cs *CalendarService) DeleteEvent(ctx context.Context, token *oauth2.Token, eventID string) error <span class="cov0" title="0">{
        client := cs.config.Client(ctx, token)
        service, err := calendar.NewService(ctx, option.WithHTTPClient(client))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create calendar service: %w", err)
        }</span>

        <span class="cov0" title="0">err = service.Events.Delete("primary", eventID).Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete calendar event: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SyncTasksToCalendar syncs all active tasks to calendar
func (cs *CalendarService) SyncTasksToCalendar(ctx context.Context, token *oauth2.Token, tasks []*domain.Task, userEmail string) (int, []string) <span class="cov0" title="0">{
        var synced int
        var errors []string

        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.Stage == domain.StageActive &amp;&amp; len(task.Schedule.WorkIntervals) &gt; 0 </span><span class="cov0" title="0">{
                        eventID, err := cs.CreateOrUpdateEvent(ctx, token, task, userEmail)
                        if err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Task %s: %v", task.ID, err))
                                continue</span>
                        }

                        // Update task with event ID (this should be persisted by the caller)
                        <span class="cov0" title="0">task.GoogleCalendarEventID = eventID
                        synced++</span>
                }
        }

        <span class="cov0" title="0">return synced, errors</span>
}

// SyncCalendarToTasks syncs calendar changes back to tasks
func (cs *CalendarService) SyncCalendarToTasks(ctx context.Context, token *oauth2.Token, tasks []*domain.Task) ([]*domain.Task, []string) <span class="cov0" title="0">{
        client := cs.config.Client(ctx, token)
        service, err := calendar.NewService(ctx, option.WithHTTPClient(client))
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{fmt.Sprintf("failed to create calendar service: %v", err)}
        }</span>

        <span class="cov0" title="0">var updatedTasks []*domain.Task
        var errors []string

        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.GoogleCalendarEventID == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">event, err := service.Events.Get("primary", task.GoogleCalendarEventID).Do()
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Task %s: failed to get calendar event: %v", task.ID, err))
                        continue</span>
                }

                // Update task based on calendar event
                <span class="cov0" title="0">updated := cs.updateTaskFromCalendarEvent(task, event)
                if updated </span><span class="cov0" title="0">{
                        updatedTasks = append(updatedTasks, task)
                }</span>
        }

        <span class="cov0" title="0">return updatedTasks, errors</span>
}

// taskToCalendarEvent converts a task to a calendar event
func (cs *CalendarService) taskToCalendarEvent(task *domain.Task, userEmail string) *calendar.Event <span class="cov0" title="0">{
        event := &amp;calendar.Event{
                Summary:     task.Name,
                Description: task.Description,
                Attendees: []*calendar.EventAttendee{
                        {Email: userEmail},
                },
        }

        // Set time based on work intervals
        if len(task.Schedule.WorkIntervals) &gt; 0 </span><span class="cov0" title="0">{
                interval := task.Schedule.WorkIntervals[len(task.Schedule.WorkIntervals)-1] // Latest interval

                if !interval.Start.IsZero() </span><span class="cov0" title="0">{
                        event.Start = &amp;calendar.EventDateTime{
                                DateTime: interval.Start.Format(time.RFC3339),
                                TimeZone: "UTC",
                        }
                }</span>

                <span class="cov0" title="0">if !interval.Stop.IsZero() </span><span class="cov0" title="0">{
                        event.End = &amp;calendar.EventDateTime{
                                DateTime: interval.Stop.Format(time.RFC3339),
                                TimeZone: "UTC",
                        }
                }</span> else<span class="cov0" title="0"> if !interval.Start.IsZero() </span><span class="cov0" title="0">{
                        // If no end time, assume 1 hour duration
                        endTime := interval.Start.Add(time.Hour)
                        event.End = &amp;calendar.EventDateTime{
                                DateTime: endTime.Format(time.RFC3339),
                                TimeZone: "UTC",
                        }
                }</span>
        }

        // Add task metadata as extended properties
        <span class="cov0" title="0">if event.ExtendedProperties == nil </span><span class="cov0" title="0">{
                event.ExtendedProperties = &amp;calendar.EventExtendedProperties{}
        }</span>
        <span class="cov0" title="0">if event.ExtendedProperties.Private == nil </span><span class="cov0" title="0">{
                event.ExtendedProperties.Private = make(map[string]string)
        }</span>
        <span class="cov0" title="0">event.ExtendedProperties.Private["task_id"] = task.ID
        event.ExtendedProperties.Private["task_stage"] = task.Stage.String()

        return event</span>
}

// updateTaskFromCalendarEvent updates task based on calendar event changes
func (cs *CalendarService) updateTaskFromCalendarEvent(task *domain.Task, event *calendar.Event) bool <span class="cov0" title="0">{
        updated := false

        // Update name if changed
        if event.Summary != task.Name </span><span class="cov0" title="0">{
                task.Name = event.Summary
                updated = true
        }</span>

        // Update description if changed
        <span class="cov0" title="0">if event.Description != task.Description </span><span class="cov0" title="0">{
                task.Description = event.Description
                updated = true
        }</span>

        // Update work intervals if time changed
        <span class="cov0" title="0">if event.Start != nil &amp;&amp; event.End != nil &amp;&amp; len(task.Schedule.WorkIntervals) &gt; 0 </span><span class="cov0" title="0">{
                interval := &amp;task.Schedule.WorkIntervals[len(task.Schedule.WorkIntervals)-1]

                if event.Start.DateTime != "" </span><span class="cov0" title="0">{
                        startTime, err := time.Parse(time.RFC3339, event.Start.DateTime)
                        if err == nil &amp;&amp; !startTime.Equal(interval.Start) </span><span class="cov0" title="0">{
                                interval.Start = startTime
                                updated = true
                        }</span>
                }

                <span class="cov0" title="0">if event.End.DateTime != "" </span><span class="cov0" title="0">{
                        endTime, err := time.Parse(time.RFC3339, event.End.DateTime)
                        if err == nil &amp;&amp; !endTime.Equal(interval.Stop) </span><span class="cov0" title="0">{
                                interval.Stop = endTime
                                updated = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if updated </span><span class="cov0" title="0">{
                task.AddStatusUpdate("Updated from calendar sync")
        }</span>

        <span class="cov0" title="0">return updated</span>
}

// StartSyncScheduler starts a background scheduler for periodic calendar sync
func (cs *CalendarService) StartSyncScheduler(ctx context.Context, interval time.Duration, syncFunc func()) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        log.Printf("Calendar sync scheduler started with interval: %v", interval)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("Calendar sync scheduler stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        log.Println("Running scheduled calendar sync...")
                        syncFunc()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
)

// TagType represents the type of a tag value
type TagType int

const (
        TagTypeUnspecified TagType = iota
        TagTypeText
        TagTypeLocation
        TagTypeTime
)

func (t TagType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case TagTypeText:<span class="cov0" title="0">
                return "text"</span>
        case TagTypeLocation:<span class="cov0" title="0">
                return "location"</span>
        case TagTypeTime:<span class="cov0" title="0">
                return "time"</span>
        default:<span class="cov0" title="0">
                return "unspecified"</span>
        }
}

// GeographicLocation represents a geographic location
type GeographicLocation struct {
        Latitude  float64
        Longitude float64
        Address   string
}

// TagValue represents a typed tag value
type TagValue struct {
        Type          TagType
        TextValue     string
        LocationValue *GeographicLocation
        TimeValue     *time.Time
}

// String returns a string representation of the TagValue
func (tv TagValue) String() string <span class="cov0" title="0">{
        switch tv.Type </span>{
        case TagTypeText:<span class="cov0" title="0">
                return tv.TextValue</span>
        case TagTypeLocation:<span class="cov0" title="0">
                if tv.LocationValue != nil </span><span class="cov0" title="0">{
                        return tv.LocationValue.Address
                }</span>
                <span class="cov0" title="0">return ""</span>
        case TagTypeTime:<span class="cov0" title="0">
                if tv.TimeValue != nil </span><span class="cov0" title="0">{
                        return tv.TimeValue.Format("2006-01-02")
                }</span>
                <span class="cov0" title="0">return ""</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// NotificationType represents types of notifications
type NotificationType int

const (
        NotificationTypeUnspecified NotificationType = iota
        NotificationOnAssign
        NotificationOnStart
        NotificationNDaysBeforeDue
)

func (n NotificationType) String() string <span class="cov0" title="0">{
        switch n </span>{
        case NotificationOnAssign:<span class="cov0" title="0">
                return "on_assign"</span>
        case NotificationOnStart:<span class="cov0" title="0">
                return "on_start"</span>
        case NotificationNDaysBeforeDue:<span class="cov0" title="0">
                return "n_days_before_due"</span>
        default:<span class="cov0" title="0">
                return "unspecified"</span>
        }
}

// NotificationSetting represents user notification preferences
type NotificationSetting struct {
        Type       NotificationType
        Enabled    bool
        DaysBefore int32 // For N_DAYS_BEFORE_DUE type
}

// User represents a user in the system
type User struct {
        ID                   string
        Email                string
        Name                 string
        GoogleCalendarToken  string
        NotificationSettings []NotificationSetting
}

// ShortID generates a short unique identifier from a UUID
func ShortID() string <span class="cov8" title="1">{
        return strings.ReplaceAll(uuid.New().String(), "-", "")[:8]
}</span>

// TaskStage represents the lifecycle stage of a task
type TaskStage int

const (
        StagePending TaskStage = iota
        StageInbox
        StageStaging
        StageActive
        StageArchived
)

func (s TaskStage) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StagePending:<span class="cov8" title="1">
                return "pending"</span>
        case StageInbox:<span class="cov8" title="1">
                return "inbox"</span>
        case StageStaging:<span class="cov8" title="1">
                return "staging"</span>
        case StageActive:<span class="cov8" title="1">
                return "active"</span>
        case StageArchived:<span class="cov8" title="1">
                return "archived"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// TaskStatus represents the detailed status within a stage
type TaskStatus int

const (
        StatusUnspecified TaskStatus = iota
        StatusTodo
        StatusInProgress
        StatusPaused
        StatusBlocked
        StatusCompleted
        StatusCancelled
)

func (s TaskStatus) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StatusTodo:<span class="cov8" title="1">
                return "todo"</span>
        case StatusInProgress:<span class="cov8" title="1">
                return "in_progress"</span>
        case StatusPaused:<span class="cov8" title="1">
                return "paused"</span>
        case StatusBlocked:<span class="cov8" title="1">
                return "blocked"</span>
        case StatusCompleted:<span class="cov8" title="1">
                return "completed"</span>
        case StatusCancelled:<span class="cov8" title="1">
                return "cancelled"</span>
        default:<span class="cov8" title="1">
                return "unspecified"</span>
        }
}

// Point represents a work tracking unit
type Point struct {
        Title string
        Value uint32
}

// WorkInterval represents a scheduled work period
type WorkInterval struct {
        Start           time.Time
        Stop            time.Time
        PointsCompleted []Point
}

// Schedule contains scheduling information for a task
type Schedule struct {
        WorkIntervals []WorkInterval
        Due           time.Time
}

// StatusUpdate represents a status change event
type StatusUpdate struct {
        Time   time.Time
        Update string
}

// Status tracks the history of status updates
type Status struct {
        Updates []StatusUpdate
}

// Task represents a unit of work in the system
type Task struct {
        ID                    string
        Name                  string
        Description           string
        Stage                 TaskStage
        Status                TaskStatus
        Location              []string            // hierarchical path
        Points                []Point             // work units to complete
        Schedule              Schedule            // scheduling information
        StatusHist            Status              // status update history
        Tags                  map[string]TagValue // user configurable metadata with types
        Inflows               []string            // task IDs this depends on
        Outflows              []string            // task IDs that depend on this
        UserID                string              // owner of the task
        GoogleCalendarEventID string              // for calendar sync
        CreatedAt             time.Time
        UpdatedAt             time.Time
}

// NewTask creates a new task in pending stage
func NewTask(name, description, userID string) *Task <span class="cov8" title="1">{
        now := time.Now()
        return &amp;Task{
                ID:          ShortID(),
                Name:        name,
                Description: description,
                Stage:       StagePending,
                Status:      StatusTodo,
                Location:    []string{},
                Points:      []Point{},
                Schedule:    Schedule{},
                StatusHist:  Status{Updates: []StatusUpdate{}},
                Tags:        make(map[string]TagValue),
                Inflows:     []string{},
                Outflows:    []string{},
                UserID:      userID,
                CreatedAt:   now,
                UpdatedAt:   now,
        }
}</span>

// TotalPoints calculates the total point value for the task
func (t *Task) TotalPoints() uint32 <span class="cov8" title="1">{
        var total uint32
        for _, point := range t.Points </span><span class="cov8" title="1">{
                total += point.Value
        }</span>
        <span class="cov8" title="1">return total</span>
}

// CompletedPoints calculates the total completed points across all work intervals
func (t *Task) CompletedPoints() uint32 <span class="cov8" title="1">{
        var total uint32
        for _, interval := range t.Schedule.WorkIntervals </span><span class="cov8" title="1">{
                for _, point := range interval.PointsCompleted </span><span class="cov8" title="1">{
                        total += point.Value
                }</span>
        }
        <span class="cov8" title="1">return total</span>
}

// IsComplete returns true if all points have been completed
func (t *Task) IsComplete() bool <span class="cov8" title="1">{
        return t.CompletedPoints() &gt;= t.TotalPoints() &amp;&amp; t.TotalPoints() &gt; 0
}</span>

// CanMoveToStaging validates if a task can be moved to staging
func (t *Task) CanMoveToStaging() error <span class="cov8" title="1">{
        if t.Stage != StagePending &amp;&amp; t.Stage != StageInbox </span><span class="cov8" title="1">{
                return fmt.Errorf("task %s is in stage %s, can only move to staging from pending or inbox", t.ID, t.Stage)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CanStart validates if a task can be started
func (t *Task) CanStart() error <span class="cov8" title="1">{
        if t.Stage != StageStaging </span><span class="cov8" title="1">{
                return fmt.Errorf("task %s is in stage %s, can only start tasks in staging", t.ID, t.Stage)
        }</span>
        <span class="cov8" title="1">if t.Status == StatusInProgress </span><span class="cov8" title="1">{
                return fmt.Errorf("task %s is already in progress", t.ID)
        }</span>
        <span class="cov8" title="1">if t.Status == StatusCompleted </span><span class="cov8" title="1">{
                return fmt.Errorf("task %s is already completed", t.ID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CanStop validates if a task can be stopped
func (t *Task) CanStop() error <span class="cov8" title="1">{
        if t.Status != StatusInProgress </span><span class="cov8" title="1">{
                return fmt.Errorf("task %s is not in progress, current status: %s", t.ID, t.Status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddStatusUpdate adds a new status update
func (t *Task) AddStatusUpdate(update string) <span class="cov8" title="1">{
        t.StatusHist.Updates = append(t.StatusHist.Updates, StatusUpdate{
                Time:   time.Now(),
                Update: update,
        })
        t.UpdatedAt = time.Now()
}</span>

// LocationPath returns the location as a path string
func (t *Task) LocationPath() string <span class="cov8" title="1">{
        return strings.Join(t.Location, "/")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package email

import (
        "fmt"
        "net/smtp"
        "strings"
        "time"

        "github.com/DaDevFox/task-systems/task-core/internal/domain"
)

// EmailService handles email notifications
type EmailService struct {
        smtpHost  string
        smtpPort  string
        username  string
        password  string
        fromEmail string
}

// NewEmailService creates a new email service
func NewEmailService(smtpHost, smtpPort, username, password, fromEmail string) *EmailService <span class="cov0" title="0">{
        return &amp;EmailService{
                smtpHost:  smtpHost,
                smtpPort:  smtpPort,
                username:  username,
                password:  password,
                fromEmail: fromEmail,
        }
}</span>

// SendTaskAssignedNotification sends notification when a task is assigned
func (es *EmailService) SendTaskAssignedNotification(user *domain.User, task *domain.Task) error <span class="cov0" title="0">{
        if !es.isNotificationEnabled(user, domain.NotificationOnAssign) </span><span class="cov0" title="0">{
                return nil // User has disabled this notification
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("Task Assigned: %s", task.Name)
        body := fmt.Sprintf(`Hi %s,

You have been assigned a new task:

Task: %s
Description: %s
Stage: %s
Location: %s

You can view and manage this task in your task management system.

Best regards,
Task Management System
`, user.Name, task.Name, task.Description, task.Stage.String(), task.LocationPath())

        return es.sendEmail(user.Email, subject, body)</span>
}

// SendTaskStartedNotification sends notification when a task is started
func (es *EmailService) SendTaskStartedNotification(user *domain.User, task *domain.Task) error <span class="cov0" title="0">{
        if !es.isNotificationEnabled(user, domain.NotificationOnStart) </span><span class="cov0" title="0">{
                return nil // User has disabled this notification
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("Task Started: %s", task.Name)
        body := fmt.Sprintf(`Hi %s,

Your task has been started:

Task: %s
Description: %s
Started: %s

Keep up the good work!

Best regards,
Task Management System
`, user.Name, task.Name, task.Description, time.Now().Format("2006-01-02 15:04:05"))

        return es.sendEmail(user.Email, subject, body)</span>
}

// SendTaskDueReminderNotification sends notification N days before due date
func (es *EmailService) SendTaskDueReminderNotification(user *domain.User, task *domain.Task, daysBefore int32) error <span class="cov0" title="0">{
        setting := es.getDaysBeforeSetting(user)
        if setting == nil || !setting.Enabled || setting.DaysBefore != daysBefore </span><span class="cov0" title="0">{
                return nil // User has disabled this notification or wrong days setting
        }</span>

        <span class="cov0" title="0">subject := fmt.Sprintf("Task Due Reminder: %s", task.Name)
        dueDate := task.Schedule.Due.Format("2006-01-02")
        body := fmt.Sprintf(`Hi %s,

This is a reminder that your task is due in %d days:

Task: %s
Description: %s
Due Date: %s
Location: %s

Please make sure to complete it on time.

Best regards,
Task Management System
`, user.Name, daysBefore, task.Name, task.Description, dueDate, task.LocationPath())

        return es.sendEmail(user.Email, subject, body)</span>
}

// CheckAndSendDueReminders checks all tasks and sends due reminders
func (es *EmailService) CheckAndSendDueReminders(users []*domain.User, tasks []*domain.Task) error <span class="cov0" title="0">{
        now := time.Now()

        for _, user := range users </span><span class="cov0" title="0">{
                setting := es.getDaysBeforeSetting(user)
                if setting == nil || !setting.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                        if task.UserID != user.ID </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if task.Schedule.Due.IsZero() </span><span class="cov0" title="0">{
                                continue</span> // No due date set
                        }

                        <span class="cov0" title="0">daysUntilDue := int32(task.Schedule.Due.Sub(now).Hours() / 24)
                        if daysUntilDue == setting.DaysBefore </span><span class="cov0" title="0">{
                                if err := es.SendTaskDueReminderNotification(user, task, setting.DaysBefore); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to send due reminder for task %s to user %s: %w", task.ID, user.ID, err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// isNotificationEnabled checks if a notification type is enabled for the user
func (es *EmailService) isNotificationEnabled(user *domain.User, notificationType domain.NotificationType) bool <span class="cov0" title="0">{
        for _, setting := range user.NotificationSettings </span><span class="cov0" title="0">{
                if setting.Type == notificationType </span><span class="cov0" title="0">{
                        return setting.Enabled
                }</span>
        }
        <span class="cov0" title="0">return false</span> // Default to disabled if not found
}

// getDaysBeforeSetting gets the days before due notification setting for the user
func (es *EmailService) getDaysBeforeSetting(user *domain.User) *domain.NotificationSetting <span class="cov0" title="0">{
        for _, setting := range user.NotificationSettings </span><span class="cov0" title="0">{
                if setting.Type == domain.NotificationNDaysBeforeDue </span><span class="cov0" title="0">{
                        return &amp;setting
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// sendEmail sends an email using SMTP
func (es *EmailService) sendEmail(to, subject, body string) error <span class="cov0" title="0">{
        auth := smtp.PlainAuth("", es.username, es.password, es.smtpHost)

        msg := fmt.Sprintf("To: %s\r\nSubject: %s\r\n\r\n%s", to, subject, body)

        err := smtp.SendMail(
                es.smtpHost+":"+es.smtpPort,
                auth,
                es.fromEmail,
                []string{to},
                []byte(msg),
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email to %s: %w", to, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateConfiguration validates the email service configuration
func (es *EmailService) ValidateConfiguration() error <span class="cov0" title="0">{
        if es.smtpHost == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SMTP host is required")
        }</span>
        <span class="cov0" title="0">if es.smtpPort == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SMTP port is required")
        }</span>
        <span class="cov0" title="0">if es.username == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SMTP username is required")
        }</span>
        <span class="cov0" title="0">if es.password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SMTP password is required")
        }</span>
        <span class="cov0" title="0">if es.fromEmail == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("from email is required")
        }</span>
        <span class="cov0" title="0">if !strings.Contains(es.fromEmail, "@") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid from email format")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package grpc

import (
        "context"
        "fmt"

        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/DaDevFox/task-systems/task-core/internal/domain"
        "github.com/DaDevFox/task-systems/task-core/internal/service"
        pb "github.com/DaDevFox/task-systems/task-core/proto/taskcore/v1"
)

// TaskServer implements the gRPC TaskService
type TaskServer struct {
        pb.UnimplementedTaskServiceServer
        taskService *service.TaskService
}

// NewTaskServer creates a new gRPC task server
func NewTaskServer(taskService *service.TaskService) *TaskServer <span class="cov8" title="1">{
        return &amp;TaskServer{
                taskService: taskService,
        }
}</span>

// AddTask creates a new task
func (s *TaskServer) AddTask(ctx context.Context, req *pb.AddTaskRequest) (*pb.AddTaskResponse, error) <span class="cov8" title="1">{
        if req.Name == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("task name is required")
        }</span>

        <span class="cov8" title="1">task, err := s.taskService.AddTask(ctx, req.Name, req.Description)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add task: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;pb.AddTaskResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// MoveToStaging moves a task to staging stage
func (s *TaskServer) MoveToStaging(ctx context.Context, req *pb.MoveToStagingRequest) (*pb.MoveToStagingResponse, error) <span class="cov8" title="1">{
        if req.SourceId == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source_id is required")
        }</span>

        <span class="cov8" title="1">var destinationID *string
        var newLocation []string

        switch dest := req.Destination.(type) </span>{
        case *pb.MoveToStagingRequest_DestinationId:<span class="cov0" title="0">
                destinationID = &amp;dest.DestinationId</span>
        case *pb.MoveToStagingRequest_NewLocation:<span class="cov8" title="1">
                newLocation = dest.NewLocation.NewLocation</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("either destination_id or new_location must be provided")</span>
        }

        <span class="cov8" title="1">points := s.protoPointsToDomain(req.Points)

        task, err := s.taskService.MoveToStaging(ctx, req.SourceId, destinationID, newLocation, points)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to move task to staging: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;pb.MoveToStagingResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// StartTask starts a task
func (s *TaskServer) StartTask(ctx context.Context, req *pb.StartTaskRequest) (*pb.StartTaskResponse, error) <span class="cov8" title="1">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov8" title="1">task, err := s.taskService.StartTask(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start task: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;pb.StartTaskResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// StopTask stops a task
func (s *TaskServer) StopTask(ctx context.Context, req *pb.StopTaskRequest) (*pb.StopTaskResponse, error) <span class="cov8" title="1">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov8" title="1">points := s.protoPointsToDomain(req.PointsCompleted)

        task, completed, err := s.taskService.StopTask(ctx, req.Id, points)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stop task: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;pb.StopTaskResponse{
                Task:      s.taskToProto(task),
                Completed: completed,
        }, nil</span>
}

// CompleteTask completes a task
func (s *TaskServer) CompleteTask(ctx context.Context, req *pb.CompleteTaskRequest) (*pb.CompleteTaskResponse, error) <span class="cov8" title="1">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov8" title="1">task, err := s.taskService.CompleteTask(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to complete task: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;pb.CompleteTaskResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// MergeTasks merges two tasks
func (s *TaskServer) MergeTasks(ctx context.Context, req *pb.MergeTasksRequest) (*pb.MergeTasksResponse, error) <span class="cov0" title="0">{
        if req.FromId == "" || req.ToId == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("from_id and to_id are required")
        }</span>

        <span class="cov0" title="0">task, err := s.taskService.MergeTasks(ctx, req.FromId, req.ToId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to merge tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.MergeTasksResponse{
                MergedTask: s.taskToProto(task),
        }, nil</span>
}

// SplitTask splits a task into multiple tasks
func (s *TaskServer) SplitTask(ctx context.Context, req *pb.SplitTaskRequest) (*pb.SplitTaskResponse, error) <span class="cov0" title="0">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov0" title="0">if len(req.NewNames) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least one new task name is required")
        }</span>

        <span class="cov0" title="0">if len(req.NewNames) != len(req.NewDescriptions) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("new names and descriptions must have the same length")
        }</span>

        <span class="cov0" title="0">tasks, err := s.taskService.SplitTask(ctx, req.Id, req.NewNames, req.NewDescriptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to split task: %w", err)
        }</span>

        <span class="cov0" title="0">var protoTasks []*pb.Task
        for _, task := range tasks </span><span class="cov0" title="0">{
                protoTasks = append(protoTasks, s.taskToProto(task))
        }</span>

        <span class="cov0" title="0">return &amp;pb.SplitTaskResponse{
                NewTasks: protoTasks,
        }, nil</span>
}

// AdvertiseTask makes a task flow into multiple targets
func (s *TaskServer) AdvertiseTask(ctx context.Context, req *pb.AdvertiseTaskRequest) (*pb.AdvertiseTaskResponse, error) <span class="cov0" title="0">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov0" title="0">if len(req.TargetIds) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least one target id is required")
        }</span>

        <span class="cov0" title="0">task, err := s.taskService.AdvertiseTask(ctx, req.Id, req.TargetIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to advertise task: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.AdvertiseTaskResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// StitchTasks makes multiple tasks flow into one target
func (s *TaskServer) StitchTasks(ctx context.Context, req *pb.StitchTasksRequest) (*pb.StitchTasksResponse, error) <span class="cov0" title="0">{
        if len(req.SourceIds) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least one source id is required")
        }</span>

        <span class="cov0" title="0">if req.TargetId == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("target id is required")
        }</span>

        <span class="cov0" title="0">tasks, err := s.taskService.StitchTasks(ctx, req.SourceIds, req.TargetId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stitch tasks: %w", err)
        }</span>

        <span class="cov0" title="0">var protoTasks []*pb.Task
        for _, task := range tasks </span><span class="cov0" title="0">{
                protoTasks = append(protoTasks, s.taskToProto(task))
        }</span>

        <span class="cov0" title="0">return &amp;pb.StitchTasksResponse{
                UpdatedTasks: protoTasks,
        }, nil</span>
}

// ListTasks lists tasks by stage
func (s *TaskServer) ListTasks(ctx context.Context, req *pb.ListTasksRequest) (*pb.ListTasksResponse, error) <span class="cov8" title="1">{
        stage := s.protoStageToDomain(req.Stage)

        tasks, err := s.taskService.ListTasks(ctx, stage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tasks: %w", err)
        }</span>

        <span class="cov8" title="1">var protoTasks []*pb.Task
        for _, task := range tasks </span><span class="cov8" title="1">{
                protoTasks = append(protoTasks, s.taskToProto(task))
        }</span>

        <span class="cov8" title="1">return &amp;pb.ListTasksResponse{
                Tasks: protoTasks,
        }, nil</span>
}

// GetTask retrieves a task by ID
func (s *TaskServer) GetTask(ctx context.Context, req *pb.GetTaskRequest) (*pb.GetTaskResponse, error) <span class="cov8" title="1">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov8" title="1">task, err := s.taskService.GetTask(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get task: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;pb.GetTaskResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// UpdateTaskTags updates the tags for a task
func (s *TaskServer) UpdateTaskTags(ctx context.Context, req *pb.UpdateTaskTagsRequest) (*pb.UpdateTaskTagsResponse, error) <span class="cov0" title="0">{
        if req.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task id is required")
        }</span>

        <span class="cov0" title="0">tags := s.protoTagsToDomain(req.Tags)

        task, err := s.taskService.UpdateTaskTags(ctx, req.Id, tags)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task tags: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateTaskTagsResponse{
                Task: s.taskToProto(task),
        }, nil</span>
}

// SyncCalendar syncs tasks with Google Calendar
func (s *TaskServer) SyncCalendar(ctx context.Context, req *pb.SyncCalendarRequest) (*pb.SyncCalendarResponse, error) <span class="cov0" title="0">{
        if req.UserId == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user_id is required")
        }</span>

        <span class="cov0" title="0">synced, errors, err := s.taskService.SyncCalendar(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sync calendar: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.SyncCalendarResponse{
                TasksSynced: int32(synced),
                Errors:      errors,
        }, nil</span>
}

// GetUser retrieves a user
func (s *TaskServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) <span class="cov0" title="0">{
        if req.UserId == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user_id is required")
        }</span>

        <span class="cov0" title="0">user, err := s.taskService.GetUser(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetUserResponse{
                User: s.userToProto(user),
        }, nil</span>
}

// UpdateUser updates user information
func (s *TaskServer) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.UpdateUserResponse, error) <span class="cov0" title="0">{
        if req.User == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user is required")
        }</span>

        <span class="cov0" title="0">user := s.protoToUser(req.User)

        updatedUser, err := s.taskService.UpdateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateUserResponse{
                User: s.userToProto(updatedUser),
        }, nil</span>
}

// Helper methods for conversion between domain and protobuf types

func (s *TaskServer) taskToProto(task *domain.Task) *pb.Task <span class="cov8" title="1">{
        return &amp;pb.Task{
                Id:          task.ID,
                Name:        task.Name,
                Description: task.Description,
                Stage:       s.domainStageToProto(task.Stage),
                Location:    task.Location,
                Points:      s.domainPointsToProto(task.Points),
                Schedule:    s.domainScheduleToProto(&amp;task.Schedule),
                Status:      s.domainStatusToProto(&amp;task.StatusHist),
                Tags:        s.domainTagsToProto(task.Tags),
                Inflows:     task.Inflows,
                Outflows:    task.Outflows,
        }
}</span>

func (s *TaskServer) domainStageToProto(stage domain.TaskStage) pb.TaskStage <span class="cov8" title="1">{
        switch stage </span>{
        case domain.StagePending:<span class="cov0" title="0">
                return pb.TaskStage_STAGE_PENDING</span>
        case domain.StageInbox:<span class="cov8" title="1">
                return pb.TaskStage_STAGE_INBOX</span>
        case domain.StageStaging:<span class="cov8" title="1">
                return pb.TaskStage_STAGE_STAGING</span>
        case domain.StageActive:<span class="cov8" title="1">
                return pb.TaskStage_STAGE_ACTIVE</span>
        case domain.StageArchived:<span class="cov8" title="1">
                return pb.TaskStage_STAGE_ARCHIVED</span>
        default:<span class="cov0" title="0">
                return pb.TaskStage_STAGE_UNSPECIFIED</span>
        }
}

func (s *TaskServer) protoStageToDomain(stage pb.TaskStage) domain.TaskStage <span class="cov8" title="1">{
        switch stage </span>{
        case pb.TaskStage_STAGE_PENDING:<span class="cov0" title="0">
                return domain.StagePending</span>
        case pb.TaskStage_STAGE_INBOX:<span class="cov8" title="1">
                return domain.StageInbox</span>
        case pb.TaskStage_STAGE_STAGING:<span class="cov0" title="0">
                return domain.StageStaging</span>
        case pb.TaskStage_STAGE_ACTIVE:<span class="cov0" title="0">
                return domain.StageActive</span>
        case pb.TaskStage_STAGE_ARCHIVED:<span class="cov0" title="0">
                return domain.StageArchived</span>
        default:<span class="cov0" title="0">
                return domain.StagePending</span>
        }
}

func (s *TaskServer) domainPointsToProto(points []domain.Point) []*pb.Point <span class="cov8" title="1">{
        var protoPoints []*pb.Point
        for _, point := range points </span><span class="cov8" title="1">{
                protoPoints = append(protoPoints, &amp;pb.Point{
                        Title: point.Title,
                        Value: point.Value,
                })
        }</span>
        <span class="cov8" title="1">return protoPoints</span>
}

func (s *TaskServer) protoPointsToDomain(protoPoints []*pb.Point) []domain.Point <span class="cov8" title="1">{
        var points []domain.Point
        for _, protoPoint := range protoPoints </span><span class="cov8" title="1">{
                points = append(points, domain.Point{
                        Title: protoPoint.Title,
                        Value: protoPoint.Value,
                })
        }</span>
        <span class="cov8" title="1">return points</span>
}

func (s *TaskServer) domainScheduleToProto(schedule *domain.Schedule) *pb.Schedule <span class="cov8" title="1">{
        var protoIntervals []*pb.WorkInterval
        for _, interval := range schedule.WorkIntervals </span><span class="cov8" title="1">{
                protoInterval := &amp;pb.WorkInterval{
                        PointsCompleted: s.domainPointsToProto(interval.PointsCompleted),
                }

                if !interval.Start.IsZero() </span><span class="cov8" title="1">{
                        protoInterval.Start = timestamppb.New(interval.Start)
                }</span>

                <span class="cov8" title="1">if !interval.Stop.IsZero() </span><span class="cov8" title="1">{
                        protoInterval.Stop = timestamppb.New(interval.Stop)
                }</span>

                <span class="cov8" title="1">protoIntervals = append(protoIntervals, protoInterval)</span>
        }

        <span class="cov8" title="1">protoSchedule := &amp;pb.Schedule{
                WorkIntervals: protoIntervals,
        }

        if !schedule.Due.IsZero() </span><span class="cov0" title="0">{
                protoSchedule.Due = timestamppb.New(schedule.Due)
        }</span>

        <span class="cov8" title="1">return protoSchedule</span>
}

func (s *TaskServer) domainStatusToProto(status *domain.Status) *pb.Status <span class="cov8" title="1">{
        var protoUpdates []*pb.StatusUpdate
        for _, update := range status.Updates </span><span class="cov8" title="1">{
                protoUpdate := &amp;pb.StatusUpdate{
                        Update: update.Update,
                }

                if !update.Time.IsZero() </span><span class="cov8" title="1">{
                        protoUpdate.Time = timestamppb.New(update.Time)
                }</span>

                <span class="cov8" title="1">protoUpdates = append(protoUpdates, protoUpdate)</span>
        }

        <span class="cov8" title="1">return &amp;pb.Status{
                Updates: protoUpdates,
        }</span>
}

// domainTagsToProto converts domain tags to proto tags
func (s *TaskServer) domainTagsToProto(tags map[string]domain.TagValue) map[string]*pb.TagValue <span class="cov8" title="1">{
        protoTags := make(map[string]*pb.TagValue)
        for key, value := range tags </span><span class="cov0" title="0">{
                protoTags[key] = s.domainTagValueToProto(&amp;value)
        }</span>
        <span class="cov8" title="1">return protoTags</span>
}

// domainTagValueToProto converts a domain tag value to proto tag value
func (s *TaskServer) domainTagValueToProto(value *domain.TagValue) *pb.TagValue <span class="cov0" title="0">{
        protoValue := &amp;pb.TagValue{
                Type: s.domainTagTypeToProto(value.Type),
        }

        switch value.Type </span>{
        case domain.TagTypeText:<span class="cov0" title="0">
                protoValue.Value = &amp;pb.TagValue_TextValue{TextValue: value.TextValue}</span>
        case domain.TagTypeLocation:<span class="cov0" title="0">
                if value.LocationValue != nil </span><span class="cov0" title="0">{
                        protoValue.Value = &amp;pb.TagValue_LocationValue{
                                LocationValue: &amp;pb.GeographicLocation{
                                        Latitude:  value.LocationValue.Latitude,
                                        Longitude: value.LocationValue.Longitude,
                                        Address:   value.LocationValue.Address,
                                },
                        }
                }</span>
        case domain.TagTypeTime:<span class="cov0" title="0">
                if value.TimeValue != nil </span><span class="cov0" title="0">{
                        protoValue.Value = &amp;pb.TagValue_TimeValue{
                                TimeValue: timestamppb.New(*value.TimeValue),
                        }
                }</span>
        }

        <span class="cov0" title="0">return protoValue</span>
}

// domainTagTypeToProto converts domain tag type to proto tag type
func (s *TaskServer) domainTagTypeToProto(tagType domain.TagType) pb.TagType <span class="cov0" title="0">{
        switch tagType </span>{
        case domain.TagTypeText:<span class="cov0" title="0">
                return pb.TagType_TAG_TYPE_TEXT</span>
        case domain.TagTypeLocation:<span class="cov0" title="0">
                return pb.TagType_TAG_TYPE_LOCATION</span>
        case domain.TagTypeTime:<span class="cov0" title="0">
                return pb.TagType_TAG_TYPE_TIME</span>
        default:<span class="cov0" title="0">
                return pb.TagType_TAG_TYPE_UNSPECIFIED</span>
        }
}

// Enhanced conversion functions

func (s *TaskServer) protoTagsToDomain(protoTags map[string]*pb.TagValue) map[string]domain.TagValue <span class="cov0" title="0">{
        tags := make(map[string]domain.TagValue)
        for key, protoValue := range protoTags </span><span class="cov0" title="0">{
                tags[key] = s.protoToTagValue(protoValue)
        }</span>
        <span class="cov0" title="0">return tags</span>
}

func (s *TaskServer) protoToTagValue(protoValue *pb.TagValue) domain.TagValue <span class="cov0" title="0">{
        value := domain.TagValue{
                Type: s.protoToTagType(protoValue.Type),
        }

        switch v := protoValue.Value.(type) </span>{
        case *pb.TagValue_TextValue:<span class="cov0" title="0">
                value.TextValue = v.TextValue</span>
        case *pb.TagValue_LocationValue:<span class="cov0" title="0">
                value.LocationValue = &amp;domain.GeographicLocation{
                        Latitude:  v.LocationValue.Latitude,
                        Longitude: v.LocationValue.Longitude,
                        Address:   v.LocationValue.Address,
                }</span>
        case *pb.TagValue_TimeValue:<span class="cov0" title="0">
                time := v.TimeValue.AsTime()
                value.TimeValue = &amp;time</span>
        }

        <span class="cov0" title="0">return value</span>
}

func (s *TaskServer) protoToTagType(protoType pb.TagType) domain.TagType <span class="cov0" title="0">{
        switch protoType </span>{
        case pb.TagType_TAG_TYPE_TEXT:<span class="cov0" title="0">
                return domain.TagTypeText</span>
        case pb.TagType_TAG_TYPE_LOCATION:<span class="cov0" title="0">
                return domain.TagTypeLocation</span>
        case pb.TagType_TAG_TYPE_TIME:<span class="cov0" title="0">
                return domain.TagTypeTime</span>
        default:<span class="cov0" title="0">
                return domain.TagTypeUnspecified</span>
        }
}

func (s *TaskServer) userToProto(user *domain.User) *pb.User <span class="cov0" title="0">{
        return &amp;pb.User{
                Id:                   user.ID,
                Email:                user.Email,
                Name:                 user.Name,
                GoogleCalendarToken:  user.GoogleCalendarToken,
                NotificationSettings: s.notificationSettingsToProto(user.NotificationSettings),
        }
}</span>

func (s *TaskServer) protoToUser(pbUser *pb.User) *domain.User <span class="cov0" title="0">{
        return &amp;domain.User{
                ID:                   pbUser.Id,
                Email:                pbUser.Email,
                Name:                 pbUser.Name,
                GoogleCalendarToken:  pbUser.GoogleCalendarToken,
                NotificationSettings: s.protoToNotificationSettings(pbUser.NotificationSettings),
        }
}</span>

func (s *TaskServer) notificationSettingsToProto(settings []domain.NotificationSetting) []*pb.NotificationSetting <span class="cov0" title="0">{
        var protoSettings []*pb.NotificationSetting
        for _, setting := range settings </span><span class="cov0" title="0">{
                protoSettings = append(protoSettings, &amp;pb.NotificationSetting{
                        Type:       s.notificationTypeToProto(setting.Type),
                        Enabled:    setting.Enabled,
                        DaysBefore: setting.DaysBefore,
                })
        }</span>
        <span class="cov0" title="0">return protoSettings</span>
}

func (s *TaskServer) protoToNotificationSettings(protoSettings []*pb.NotificationSetting) []domain.NotificationSetting <span class="cov0" title="0">{
        var settings []domain.NotificationSetting
        for _, protoSetting := range protoSettings </span><span class="cov0" title="0">{
                settings = append(settings, domain.NotificationSetting{
                        Type:       s.protoToNotificationType(protoSetting.Type),
                        Enabled:    protoSetting.Enabled,
                        DaysBefore: protoSetting.DaysBefore,
                })
        }</span>
        <span class="cov0" title="0">return settings</span>
}

func (s *TaskServer) notificationTypeToProto(notType domain.NotificationType) pb.NotificationType <span class="cov0" title="0">{
        switch notType </span>{
        case domain.NotificationOnAssign:<span class="cov0" title="0">
                return pb.NotificationType_NOTIFICATION_ON_ASSIGN</span>
        case domain.NotificationOnStart:<span class="cov0" title="0">
                return pb.NotificationType_NOTIFICATION_ON_START</span>
        case domain.NotificationNDaysBeforeDue:<span class="cov0" title="0">
                return pb.NotificationType_NOTIFICATION_N_DAYS_BEFORE_DUE</span>
        default:<span class="cov0" title="0">
                return pb.NotificationType_NOTIFICATION_TYPE_UNSPECIFIED</span>
        }
}

func (s *TaskServer) protoToNotificationType(protoType pb.NotificationType) domain.NotificationType <span class="cov0" title="0">{
        switch protoType </span>{
        case pb.NotificationType_NOTIFICATION_ON_ASSIGN:<span class="cov0" title="0">
                return domain.NotificationOnAssign</span>
        case pb.NotificationType_NOTIFICATION_ON_START:<span class="cov0" title="0">
                return domain.NotificationOnStart</span>
        case pb.NotificationType_NOTIFICATION_N_DAYS_BEFORE_DUE:<span class="cov0" title="0">
                return domain.NotificationNDaysBeforeDue</span>
        default:<span class="cov0" title="0">
                return domain.NotificationTypeUnspecified</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "context"
        "fmt"
        "sync"

        "github.com/DaDevFox/task-systems/task-core/internal/domain"
)

// InMemoryTaskRepository is a simple in-memory implementation of TaskRepository
type InMemoryTaskRepository struct {
        tasks map[string]*domain.Task
        mutex sync.RWMutex
}

// NewInMemoryTaskRepository creates a new in-memory task repository
func NewInMemoryTaskRepository() *InMemoryTaskRepository <span class="cov8" title="1">{
        return &amp;InMemoryTaskRepository{
                tasks: make(map[string]*domain.Task),
        }
}</span>

// Create stores a new task
func (r *InMemoryTaskRepository) Create(ctx context.Context, task *domain.Task) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        // Check if task already exists
        if _, exists := r.tasks[task.ID]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("task with ID %s already exists", task.ID)
        }</span>

        // Create a copy to avoid external modifications
        <span class="cov8" title="1">taskCopy := *task
        r.tasks[task.ID] = &amp;taskCopy
        return nil</span>
}

// GetByID retrieves a task by its ID
func (r *InMemoryTaskRepository) GetByID(ctx context.Context, id string) (*domain.Task, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        task, exists := r.tasks[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, ErrTaskNotFound
        }</span>

        // Return a copy to avoid external modifications
        <span class="cov8" title="1">taskCopy := *task
        return &amp;taskCopy, nil</span>
}

// Update updates an existing task
func (r *InMemoryTaskRepository) Update(ctx context.Context, task *domain.Task) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.tasks[task.ID]; !exists </span><span class="cov8" title="1">{
                return ErrTaskNotFound
        }</span>

        // Create a copy to avoid external modifications
        <span class="cov8" title="1">taskCopy := *task
        r.tasks[task.ID] = &amp;taskCopy
        return nil</span>
}

// Delete removes a task
func (r *InMemoryTaskRepository) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.tasks[id]; !exists </span><span class="cov8" title="1">{
                return ErrTaskNotFound
        }</span>

        <span class="cov8" title="1">delete(r.tasks, id)
        return nil</span>
}

// ListByStage returns all tasks in a given stage
func (r *InMemoryTaskRepository) ListByStage(ctx context.Context, stage domain.TaskStage) ([]*domain.Task, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var tasks []*domain.Task
        for _, task := range r.tasks </span><span class="cov8" title="1">{
                if task.Stage == stage </span><span class="cov8" title="1">{
                        taskCopy := *task
                        tasks = append(tasks, &amp;taskCopy)
                }</span>
        }

        <span class="cov8" title="1">return tasks, nil</span>
}

// ListAll returns all tasks
func (r *InMemoryTaskRepository) ListAll(ctx context.Context) ([]*domain.Task, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var tasks []*domain.Task
        for _, task := range r.tasks </span><span class="cov8" title="1">{
                taskCopy := *task
                tasks = append(tasks, &amp;taskCopy)
        }</span>

        <span class="cov8" title="1">return tasks, nil</span>
}

// CountByStage returns the number of tasks in a given stage
func (r *InMemoryTaskRepository) CountByStage(ctx context.Context, stage domain.TaskStage) (int, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        count := 0
        for _, task := range r.tasks </span><span class="cov8" title="1">{
                if task.Stage == stage </span><span class="cov8" title="1">{
                        count++
                }</span>
        }

        <span class="cov8" title="1">return count, nil</span>
}

// GetTasksByIDs retrieves multiple tasks by their IDs
func (r *InMemoryTaskRepository) GetTasksByIDs(ctx context.Context, ids []string) ([]*domain.Task, error) <span class="cov8" title="1">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var tasks []*domain.Task
        var notFound []string

        for _, id := range ids </span><span class="cov8" title="1">{
                if task, exists := r.tasks[id]; exists </span><span class="cov8" title="1">{
                        taskCopy := *task
                        tasks = append(tasks, &amp;taskCopy)
                }</span> else<span class="cov8" title="1"> {
                        notFound = append(notFound, id)
                }</span>
        }

        <span class="cov8" title="1">if len(notFound) &gt; 0 </span><span class="cov8" title="1">{
                return tasks, fmt.Errorf("tasks not found: %v", notFound)
        }</span>

        <span class="cov8" title="1">return tasks, nil</span>
}

// ListByStageAndUser returns all tasks in a given stage for a specific user
func (r *InMemoryTaskRepository) ListByStageAndUser(ctx context.Context, stage domain.TaskStage, userID string) ([]*domain.Task, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var tasks []*domain.Task
        for _, task := range r.tasks </span><span class="cov0" title="0">{
                if task.Stage == stage &amp;&amp; task.UserID == userID </span><span class="cov0" title="0">{
                        taskCopy := *task
                        tasks = append(tasks, &amp;taskCopy)
                }</span>
        }

        <span class="cov0" title="0">return tasks, nil</span>
}

// ListByUser returns all tasks for a specific user
func (r *InMemoryTaskRepository) ListByUser(ctx context.Context, userID string) ([]*domain.Task, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var tasks []*domain.Task
        for _, task := range r.tasks </span><span class="cov0" title="0">{
                if task.UserID == userID </span><span class="cov0" title="0">{
                        taskCopy := *task
                        tasks = append(tasks, &amp;taskCopy)
                }</span>
        }

        <span class="cov0" title="0">return tasks, nil</span>
}

// InMemoryUserRepository is a simple in-memory implementation of UserRepository
type InMemoryUserRepository struct {
        users map[string]*domain.User
        mutex sync.RWMutex
}

// NewInMemoryUserRepository creates a new in-memory user repository
func NewInMemoryUserRepository() *InMemoryUserRepository <span class="cov0" title="0">{
        return &amp;InMemoryUserRepository{
                users: make(map[string]*domain.User),
        }
}</span>

// Create stores a new user
func (r *InMemoryUserRepository) Create(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        // Check if user already exists
        if _, exists := r.users[user.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("user with ID %s already exists", user.ID)
        }</span>

        // Create a copy to avoid external modifications
        <span class="cov0" title="0">userCopy := *user
        r.users[user.ID] = &amp;userCopy
        return nil</span>
}

// GetByID retrieves a user by their ID
func (r *InMemoryUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        user, exists := r.users[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>

        // Return a copy to avoid external modifications
        <span class="cov0" title="0">userCopy := *user
        return &amp;userCopy, nil</span>
}

// GetByEmail retrieves a user by their email
func (r *InMemoryUserRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        for _, user := range r.users </span><span class="cov0" title="0">{
                if user.Email == email </span><span class="cov0" title="0">{
                        userCopy := *user
                        return &amp;userCopy, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, ErrUserNotFound</span>
}

// Update updates an existing user
func (r *InMemoryUserRepository) Update(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.users[user.ID]; !exists </span><span class="cov0" title="0">{
                return ErrUserNotFound
        }</span>

        // Create a copy to avoid external modifications
        <span class="cov0" title="0">userCopy := *user
        r.users[user.ID] = &amp;userCopy
        return nil</span>
}

// Delete removes a user
func (r *InMemoryUserRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        if _, exists := r.users[id]; !exists </span><span class="cov0" title="0">{
                return ErrUserNotFound
        }</span>

        <span class="cov0" title="0">delete(r.users, id)
        return nil</span>
}

// ListAll returns all users
func (r *InMemoryUserRepository) ListAll(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        r.mutex.RLock()
        defer r.mutex.RUnlock()

        var users []*domain.User
        for _, user := range r.users </span><span class="cov0" title="0">{
                userCopy := *user
                users = append(users, &amp;userCopy)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "github.com/DaDevFox/task-systems/task-core/internal/calendar"
        "github.com/DaDevFox/task-systems/task-core/internal/domain"
        "github.com/DaDevFox/task-systems/task-core/internal/email"
        "github.com/DaDevFox/task-systems/task-core/internal/repository"
)

// TaskService provides comprehensive business logic for task management
type TaskService struct {
        repo            repository.TaskRepository
        userRepo        repository.UserRepository
        calendarService *calendar.CalendarService
        emailService    *email.EmailService
        maxInboxSize    int
        syncEnabled     bool
}

// NewTaskService creates a new task service with optional integrations
func NewTaskService(
        repo repository.TaskRepository,
        maxInboxSize int,
        userRepo repository.UserRepository,
        calendarService *calendar.CalendarService,
        emailService *email.EmailService,
) *TaskService <span class="cov8" title="1">{
        if maxInboxSize &lt;= 0 </span><span class="cov0" title="0">{
                maxInboxSize = 5 // default
        }</span>
        <span class="cov8" title="1">return &amp;TaskService{
                repo:            repo,
                userRepo:        userRepo,
                calendarService: calendarService,
                emailService:    emailService,
                maxInboxSize:    maxInboxSize,
                syncEnabled:     true,
        }</span>
}

// SetSyncEnabled enables or disables automatic calendar sync
func (s *TaskService) SetSyncEnabled(enabled bool) <span class="cov0" title="0">{
        s.syncEnabled = enabled
}</span>

// AddTask creates a new task in pending stage
func (s *TaskService) AddTask(ctx context.Context, name, description string) (*domain.Task, error) <span class="cov8" title="1">{
        return s.AddTaskForUser(ctx, name, description, "default-user")
}</span>

// AddTaskForUser creates a new task in pending stage for a specific user
func (s *TaskService) AddTaskForUser(ctx context.Context, name, description, userID string) (*domain.Task, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("task name cannot be empty")
        }</span>
        <span class="cov8" title="1">if userID == "" </span><span class="cov0" title="0">{
                userID = "default-user" // fallback for backward compatibility
        }</span>

        // Verify user exists if userRepo is available
        <span class="cov8" title="1">if s.userRepo != nil </span><span class="cov8" title="1">{
                if _, err := s.userRepo.GetByID(ctx, userID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found: %w", err)
                }</span>
        }

        <span class="cov8" title="1">task := domain.NewTask(name, description, userID)
        task.Stage = domain.StageInbox // New tasks go to inbox first
        task.AddStatusUpdate("Task created")

        err := s.repo.Create(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create task: %w", err)
        }</span>

        // Send assignment notification if email service is available
        <span class="cov8" title="1">if s.emailService != nil &amp;&amp; s.userRepo != nil </span><span class="cov0" title="0">{
                if user, userErr := s.userRepo.GetByID(ctx, userID); userErr == nil </span><span class="cov0" title="0">{
                        if err := s.emailService.SendTaskAssignedNotification(user, task); err != nil </span><span class="cov0" title="0">{
                                // Log error but don't fail the operation
                                fmt.Printf("Failed to send assignment notification: %v\n", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return task, nil</span>
}

// MoveToStaging moves a task from pending/inbox to staging
func (s *TaskService) MoveToStaging(ctx context.Context, sourceID string, destinationID *string, newLocation []string, points []domain.Point) (*domain.Task, error) <span class="cov8" title="1">{
        // Check inbox constraint before any operations
        if err := s.checkInboxConstraint(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">task, err := s.repo.GetByID(ctx, sourceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source task not found: %w", err)
        }</span>

        <span class="cov8" title="1">if err := task.CanMoveToStaging(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle destination logic
        <span class="cov8" title="1">if destinationID != nil </span><span class="cov8" title="1">{
                destTask, err := s.repo.GetByID(ctx, *destinationID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("destination task not found: %w", err)
                }</span>

                // Inherit location from destination
                <span class="cov8" title="1">task.Location = destTask.Location

                // Set up dependency: source depends on destination
                task.Inflows = append(task.Inflows, *destinationID)
                destTask.Outflows = append(destTask.Outflows, sourceID)

                // Update destination task
                if err := s.repo.Update(ctx, destTask); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update destination task: %w", err)
                }</span>
        } else<span class="cov8" title="1"> if len(newLocation) &gt; 0 </span><span class="cov8" title="1">{
                task.Location = newLocation
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("either destination_id or new_location must be provided")
        }</span>

        // Set points if provided
        <span class="cov8" title="1">if len(points) &gt; 0 </span><span class="cov8" title="1">{
                task.Points = points
        }</span>

        // Move to staging
        <span class="cov8" title="1">task.Stage = domain.StageStaging
        task.AddStatusUpdate("Moved to staging")

        err = s.repo.Update(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov8" title="1">return task, nil</span>
}

// StartTask moves a task to active stage and sets it as in progress
func (s *TaskService) StartTask(ctx context.Context, id string) (*domain.Task, error) <span class="cov8" title="1">{
        // Check inbox constraint
        if err := s.checkInboxConstraint(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">task, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %w", err)
        }</span>

        <span class="cov8" title="1">if err := task.CanStart(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check dependencies
        <span class="cov8" title="1">if err := s.checkDependencies(ctx, task); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">task.Stage = domain.StageActive
        task.Status = domain.StatusInProgress
        task.AddStatusUpdate("Task started")

        // Add work interval
        now := time.Now()
        task.Schedule.WorkIntervals = append(task.Schedule.WorkIntervals, domain.WorkInterval{
                Start: now,
                Stop:  time.Time{}, // Will be set when stopped
        })

        err = s.repo.Update(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        // Sync to calendar if enabled
        <span class="cov8" title="1">if s.syncEnabled &amp;&amp; s.calendarService != nil </span><span class="cov0" title="0">{
                go s.syncTaskToCalendar(task)
        }</span>

        // Send start notification
        <span class="cov8" title="1">if s.emailService != nil &amp;&amp; s.userRepo != nil </span><span class="cov0" title="0">{
                if user, userErr := s.userRepo.GetByID(ctx, task.UserID); userErr == nil </span><span class="cov0" title="0">{
                        if err := s.emailService.SendTaskStartedNotification(user, task); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to send start notification: %v\n", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return task, nil

        err = s.repo.Update(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov0" title="0">return task, nil</span>
}

// StopTask stops an active task and marks completed points
func (s *TaskService) StopTask(ctx context.Context, id string, pointsCompleted []domain.Point) (*domain.Task, bool, error) <span class="cov8" title="1">{
        task, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("task not found: %w", err)
        }</span>

        <span class="cov8" title="1">if err := task.CanStop(); err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        // Update the last work interval
        <span class="cov8" title="1">if len(task.Schedule.WorkIntervals) &gt; 0 </span><span class="cov8" title="1">{
                lastInterval := &amp;task.Schedule.WorkIntervals[len(task.Schedule.WorkIntervals)-1]
                lastInterval.Stop = time.Now()
                lastInterval.PointsCompleted = pointsCompleted
        }</span>

        // Check if task is complete
        <span class="cov8" title="1">isComplete := task.IsComplete()
        if isComplete </span><span class="cov0" title="0">{
                task.Status = domain.StatusCompleted
                task.Stage = domain.StageArchived
                task.AddStatusUpdate("Task completed")
        }</span> else<span class="cov8" title="1"> {
                task.Status = domain.StatusTodo
                task.Stage = domain.StageStaging
                task.AddStatusUpdate("Task stopped")
        }</span>

        <span class="cov8" title="1">err = s.repo.Update(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov8" title="1">return task, isComplete, nil</span>
}

// CompleteTask marks a task as completed
func (s *TaskService) CompleteTask(ctx context.Context, id string) (*domain.Task, error) <span class="cov8" title="1">{
        task, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %w", err)
        }</span>

        <span class="cov8" title="1">if err := task.CanStop(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Complete all remaining points
        <span class="cov8" title="1">remainingPoints := task.TotalPoints() - task.CompletedPoints()
        if remainingPoints &gt; 0 &amp;&amp; len(task.Points) &gt; 0 </span><span class="cov8" title="1">{
                // Create completion points based on original points structure
                completionPoints := make([]domain.Point, len(task.Points))
                for i, point := range task.Points </span><span class="cov8" title="1">{
                        completionPoints[i] = domain.Point{
                                Title: point.Title,
                                Value: point.Value,
                        }
                }</span>

                // Update the last work interval
                <span class="cov8" title="1">if len(task.Schedule.WorkIntervals) &gt; 0 </span><span class="cov8" title="1">{
                        lastInterval := &amp;task.Schedule.WorkIntervals[len(task.Schedule.WorkIntervals)-1]
                        lastInterval.Stop = time.Now()
                        lastInterval.PointsCompleted = completionPoints
                }</span>
        }

        <span class="cov8" title="1">task.Status = domain.StatusCompleted
        task.Stage = domain.StageArchived
        task.AddStatusUpdate("Task completed")

        err = s.repo.Update(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov8" title="1">return task, nil</span>
}

// MergeTasks combines two tasks in the same dependency chain
func (s *TaskService) MergeTasks(ctx context.Context, fromID, toID string) (*domain.Task, error) <span class="cov8" title="1">{
        fromTask, err := s.repo.GetByID(ctx, fromID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("from task not found: %w", err)
        }</span>

        <span class="cov8" title="1">toTask, err := s.repo.GetByID(ctx, toID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("to task not found: %w", err)
        }</span>

        // Validate they're in the same chain
        <span class="cov8" title="1">if err := s.validateSameChain(ctx, fromTask, toTask); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Merge data
        <span class="cov8" title="1">toTask.Description = toTask.Description + "\n" + fromTask.Description
        toTask.Points = append(toTask.Points, fromTask.Points...)

        // Merge status history
        toTask.StatusHist.Updates = append(toTask.StatusHist.Updates, fromTask.StatusHist.Updates...)

        // Merge tags
        for k, v := range fromTask.Tags </span><span class="cov0" title="0">{
                toTask.Tags[k] = v
        }</span>

        <span class="cov8" title="1">toTask.AddStatusUpdate(fmt.Sprintf("Merged with task %s", fromID))

        // Update dependencies
        if err := s.updateDependenciesForMerge(ctx, fromTask, toTask); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Delete the from task
        <span class="cov8" title="1">if err := s.repo.Delete(ctx, fromID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete from task: %w", err)
        }</span>

        // Update the to task
        <span class="cov8" title="1">if err := s.repo.Update(ctx, toTask); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update to task: %w", err)
        }</span>

        <span class="cov8" title="1">return toTask, nil</span>
}

// SplitTask creates new tasks based on the original
func (s *TaskService) SplitTask(ctx context.Context, id string, newNames, newDescriptions []string) ([]*domain.Task, error) <span class="cov8" title="1">{
        if len(newNames) != len(newDescriptions) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("new names and descriptions must have the same length")
        }</span>

        <span class="cov8" title="1">if len(newNames) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least one new task must be specified")
        }</span>

        <span class="cov8" title="1">originalTask, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("original task not found: %w", err)
        }</span>

        <span class="cov8" title="1">var newTasks []*domain.Task

        for i, name := range newNames </span><span class="cov8" title="1">{
                newTask := domain.NewTask(name, newDescriptions[i], originalTask.UserID)
                newTask.Stage = originalTask.Stage
                newTask.Location = originalTask.Location
                newTask.Tags = make(map[string]domain.TagValue)

                // Copy tags
                for k, v := range originalTask.Tags </span><span class="cov0" title="0">{
                        newTask.Tags[k] = v
                }</span>

                <span class="cov8" title="1">newTask.AddStatusUpdate(fmt.Sprintf("Split from task %s", id))

                if err := s.repo.Create(ctx, newTask); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create new task %s: %w", name, err)
                }</span>

                <span class="cov8" title="1">newTasks = append(newTasks, newTask)</span>
        }

        // Update dependencies
        <span class="cov8" title="1">if err := s.updateDependenciesForSplit(ctx, originalTask, newTasks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Delete original task
        <span class="cov8" title="1">if err := s.repo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete original task: %w", err)
        }</span>

        <span class="cov8" title="1">return newTasks, nil</span>
}

// AdvertiseTask makes one task outflow into many
func (s *TaskService) AdvertiseTask(ctx context.Context, id string, targetIDs []string) (*domain.Task, error) <span class="cov8" title="1">{
        sourceTask, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source task not found: %w", err)
        }</span>

        // Get target tasks and validate they exist
        <span class="cov8" title="1">targetTasks, err := s.repo.GetTasksByIDs(ctx, targetIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get target tasks: %w", err)
        }</span>

        // Check for chain hopping
        <span class="cov8" title="1">for _, target := range targetTasks </span><span class="cov8" title="1">{
                if err := s.checkChainHopping(ctx, sourceTask, target); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Update outflows
        <span class="cov8" title="1">for _, targetID := range targetIDs </span><span class="cov8" title="1">{
                if !contains(sourceTask.Outflows, targetID) </span><span class="cov8" title="1">{
                        sourceTask.Outflows = append(sourceTask.Outflows, targetID)
                }</span>
        }

        // Update target tasks' inflows
        <span class="cov8" title="1">for _, target := range targetTasks </span><span class="cov8" title="1">{
                if !contains(target.Inflows, id) </span><span class="cov8" title="1">{
                        target.Inflows = append(target.Inflows, id)
                }</span>
                <span class="cov8" title="1">if err := s.repo.Update(ctx, target); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update target task %s: %w", target.ID, err)
                }</span>
        }

        <span class="cov8" title="1">sourceTask.AddStatusUpdate("Task advertised to multiple targets")

        err = s.repo.Update(ctx, sourceTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update source task: %w", err)
        }</span>

        <span class="cov8" title="1">return sourceTask, nil</span>
}

// StitchTasks makes multiple tasks outflow into one
func (s *TaskService) StitchTasks(ctx context.Context, sourceIDs []string, targetID string) ([]*domain.Task, error) <span class="cov8" title="1">{
        sourceTasks, err := s.repo.GetTasksByIDs(ctx, sourceIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get source tasks: %w", err)
        }</span>

        <span class="cov8" title="1">targetTask, err := s.repo.GetByID(ctx, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("target task not found: %w", err)
        }</span>

        // Check for chain hopping
        <span class="cov8" title="1">for _, source := range sourceTasks </span><span class="cov8" title="1">{
                if err := s.checkChainHopping(ctx, source, targetTask); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Update source tasks' outflows
        <span class="cov8" title="1">var updatedTasks []*domain.Task
        for _, source := range sourceTasks </span><span class="cov8" title="1">{
                if !contains(source.Outflows, targetID) </span><span class="cov8" title="1">{
                        source.Outflows = append(source.Outflows, targetID)
                }</span>
                <span class="cov8" title="1">source.AddStatusUpdate("Task stitched to common target")

                if err := s.repo.Update(ctx, source); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update source task %s: %w", source.ID, err)
                }</span>

                <span class="cov8" title="1">updatedTasks = append(updatedTasks, source)</span>
        }

        // Update target task's inflows
        <span class="cov8" title="1">for _, sourceID := range sourceIDs </span><span class="cov8" title="1">{
                if !contains(targetTask.Inflows, sourceID) </span><span class="cov8" title="1">{
                        targetTask.Inflows = append(targetTask.Inflows, sourceID)
                }</span>
        }

        <span class="cov8" title="1">targetTask.AddStatusUpdate("Multiple tasks stitched to this target")

        if err := s.repo.Update(ctx, targetTask); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update target task: %w", err)
        }</span>

        <span class="cov8" title="1">updatedTasks = append(updatedTasks, targetTask)
        return updatedTasks, nil</span>
}

// ListTasks returns tasks by stage
func (s *TaskService) ListTasks(ctx context.Context, stage domain.TaskStage) ([]*domain.Task, error) <span class="cov0" title="0">{
        return s.repo.ListByStage(ctx, stage)
}</span>

// ListTasksByUser returns tasks for a specific user, optionally filtered by stage
func (s *TaskService) ListTasksByUser(ctx context.Context, userID string, stage *domain.TaskStage) ([]*domain.Task, error) <span class="cov8" title="1">{
        var allTasks []*domain.Task
        var err error

        if stage != nil </span><span class="cov0" title="0">{
                allTasks, err = s.repo.ListByStage(ctx, *stage)
        }</span> else<span class="cov8" title="1"> {
                // Get tasks from all stages
                stages := []domain.TaskStage{
                        domain.StagePending,
                        domain.StageInbox,
                        domain.StageStaging,
                        domain.StageActive,
                        domain.StageArchived,
                }

                for _, st := range stages </span><span class="cov8" title="1">{
                        tasks, err := s.repo.ListByStage(ctx, st)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">allTasks = append(allTasks, tasks...)</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by user ID
        <span class="cov8" title="1">var userTasks []*domain.Task
        for _, task := range allTasks </span><span class="cov8" title="1">{
                if task.UserID == userID </span><span class="cov8" title="1">{
                        userTasks = append(userTasks, task)
                }</span>
        }

        <span class="cov8" title="1">return userTasks, nil</span>
}

// GetTask retrieves a task by ID
func (s *TaskService) GetTask(ctx context.Context, id string) (*domain.Task, error) <span class="cov8" title="1">{
        return s.repo.GetByID(ctx, id)
}</span>

// UpdateTaskTags updates the tags for a task
func (s *TaskService) UpdateTaskTags(ctx context.Context, taskID string, tags map[string]domain.TagValue) (*domain.Task, error) <span class="cov8" title="1">{
        task, err := s.repo.GetByID(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %w", err)
        }</span>

        // Update tags
        <span class="cov8" title="1">for key, value := range tags </span><span class="cov8" title="1">{
                task.Tags[key] = value
        }</span>

        <span class="cov8" title="1">task.AddStatusUpdate("Tags updated")

        err = s.repo.Update(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov8" title="1">return task, nil</span>
}

// SyncCalendar syncs tasks to Google Calendar for a user
func (s *TaskService) SyncCalendar(ctx context.Context, userID string) (int, []string, error) <span class="cov8" title="1">{
        if s.calendarService == nil </span><span class="cov8" title="1">{
                return 0, nil, fmt.Errorf("calendar service not configured")
        }</span>
        <span class="cov0" title="0">if s.userRepo == nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("user repository not configured")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("user not found: %w", err)
        }</span>

        <span class="cov0" title="0">if user.GoogleCalendarToken == "" </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("user has no Google Calendar token")
        }</span>

        <span class="cov0" title="0">token, err := s.calendarService.TokenFromJSON(user.GoogleCalendarToken)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("invalid Google Calendar token: %w", err)
        }</span>

        // Get user's active tasks
        <span class="cov0" title="0">var tasks []*domain.Task
        if userAwareRepo, ok := s.repo.(interface {
                ListByStageAndUser(ctx context.Context, stage domain.TaskStage, userID string) ([]*domain.Task, error)
        }); ok </span><span class="cov0" title="0">{
                tasks, err = userAwareRepo.ListByStageAndUser(ctx, domain.StageActive, userID)
        }</span> else<span class="cov0" title="0"> {
                // Fallback: get all active tasks and filter by user
                allTasks, err := s.repo.ListByStage(ctx, domain.StageActive)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, fmt.Errorf("failed to get tasks: %w", err)
                }</span>
                <span class="cov0" title="0">for _, task := range allTasks </span><span class="cov0" title="0">{
                        if task.UserID == userID </span><span class="cov0" title="0">{
                                tasks = append(tasks, task)
                        }</span>
                }
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("failed to get user tasks: %w", err)
        }</span>

        // Sync to calendar
        <span class="cov0" title="0">synced, errors := s.calendarService.SyncTasksToCalendar(ctx, token, tasks, user.Email)

        // Update tasks with calendar event IDs
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.GoogleCalendarEventID != "" </span><span class="cov0" title="0">{
                        if updateErr := s.repo.Update(ctx, task); updateErr != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Failed to update task %s: %v", task.ID, updateErr))
                        }</span>
                }
        }

        // Sync calendar changes back to tasks
        <span class="cov0" title="0">if s.syncEnabled </span><span class="cov0" title="0">{
                updatedTasks, syncErrors := s.calendarService.SyncCalendarToTasks(ctx, token, tasks)
                errors = append(errors, syncErrors...)

                for _, task := range updatedTasks </span><span class="cov0" title="0">{
                        if updateErr := s.repo.Update(ctx, task); updateErr != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Failed to update task %s from calendar: %v", task.ID, updateErr))
                        }</span>
                }
        }

        <span class="cov0" title="0">return synced, errors, nil</span>
}

// User management methods (if userRepo is available)

// CreateUser creates a new user
func (s *TaskService) CreateUser(ctx context.Context, id, email, name string, notificationSettings []domain.NotificationSetting) (*domain.User, error) <span class="cov8" title="1">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user repository not configured")
        }</span>

        <span class="cov8" title="1">if id == "" </span><span class="cov8" title="1">{
                id = domain.ShortID()
        }</span>
        <span class="cov8" title="1">if email == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("email cannot be empty")
        }</span>
        <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("name cannot be empty")
        }</span>

        <span class="cov8" title="1">user := &amp;domain.User{
                ID:                   id,
                Email:                email,
                Name:                 name,
                NotificationSettings: notificationSettings,
        }

        err := s.userRepo.Create(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// GetUser retrieves a user by ID
func (s *TaskService) GetUser(ctx context.Context, userID string) (*domain.User, error) <span class="cov8" title="1">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user repository not configured")
        }</span>

        <span class="cov8" title="1">user, err := s.userRepo.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found: %w", err)
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// UpdateUser updates user information
func (s *TaskService) UpdateUser(ctx context.Context, user *domain.User) (*domain.User, error) <span class="cov8" title="1">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user repository not configured")
        }</span>

        <span class="cov8" title="1">err := s.userRepo.Update(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// GetTaskDAG returns tasks in topological order for DAG visualization
func (s *TaskService) GetTaskDAG(ctx context.Context, userID string) ([]*domain.Task, error) <span class="cov8" title="1">{
        var tasks []*domain.Task
        var err error

        if userAwareRepo, ok := s.repo.(interface {
                ListByUser(ctx context.Context, userID string) ([]*domain.Task, error)
        }); ok &amp;&amp; userID != "" </span><span class="cov8" title="1">{
                tasks, err = userAwareRepo.ListByUser(ctx, userID)
        }</span> else<span class="cov0" title="0"> {
                // Fallback: get all tasks and filter by user
                tasks, err = s.repo.ListAll(ctx)
                if err == nil &amp;&amp; userID != "" </span><span class="cov0" title="0">{
                        var filteredTasks []*domain.Task
                        for _, task := range tasks </span><span class="cov0" title="0">{
                                if task.UserID == userID </span><span class="cov0" title="0">{
                                        filteredTasks = append(filteredTasks, task)
                                }</span>
                        }
                        <span class="cov0" title="0">tasks = filteredTasks</span>
                }
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Perform topological sort
        <span class="cov8" title="1">return s.topologicalSort(tasks), nil</span>
}

// CheckDueReminders checks for tasks with upcoming due dates and sends notifications
func (s *TaskService) CheckDueReminders(ctx context.Context) error <span class="cov0" title="0">{
        if s.emailService == nil || s.userRepo == nil </span><span class="cov0" title="0">{
                return nil // Services not configured
        }</span>

        <span class="cov0" title="0">users, err := s.userRepo.ListAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov0" title="0">tasks, err := s.repo.ListAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return s.emailService.CheckAndSendDueReminders(users, tasks)</span>
}

// syncTaskToCalendar syncs a single task to calendar (async)
func (s *TaskService) syncTaskToCalendar(task *domain.Task) <span class="cov0" title="0">{
        if s.calendarService == nil || s.userRepo == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        user, err := s.userRepo.GetByID(ctx, task.UserID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get user for calendar sync: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if user.GoogleCalendarToken == "" </span><span class="cov0" title="0">{
                return // No token configured
        }</span>

        <span class="cov0" title="0">token, err := s.calendarService.TokenFromJSON(user.GoogleCalendarToken)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid calendar token for user %s: %v\n", user.ID, err)
                return
        }</span>

        <span class="cov0" title="0">eventID, err := s.calendarService.CreateOrUpdateEvent(ctx, token, task, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to sync task %s to calendar: %v\n", task.ID, err)
                return
        }</span>

        // Update task with event ID
        <span class="cov0" title="0">task.GoogleCalendarEventID = eventID
        if err := s.repo.Update(ctx, task); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update task %s with calendar event ID: %v\n", task.ID, err)
        }</span>
}

// topologicalSort performs topological sorting on tasks based on dependencies
func (s *TaskService) topologicalSort(tasks []*domain.Task) []*domain.Task <span class="cov8" title="1">{
        // Create maps for easy lookup
        taskMap := make(map[string]*domain.Task)
        inDegree := make(map[string]int)

        // Initialize
        for _, task := range tasks </span><span class="cov8" title="1">{
                taskMap[task.ID] = task
                inDegree[task.ID] = len(task.Inflows)
        }</span>

        // Kahn's algorithm
        <span class="cov8" title="1">var queue []*domain.Task
        var result []*domain.Task

        // Find all nodes with no incoming edges
        for _, task := range tasks </span><span class="cov8" title="1">{
                if inDegree[task.ID] == 0 </span><span class="cov8" title="1">{
                        queue = append(queue, task)
                }</span>
        }

        // Process queue
        <span class="cov8" title="1">for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                // Remove a node from queue
                current := queue[0]
                queue = queue[1:]
                result = append(result, current)

                // For each outflow (dependent task)
                for _, outflowID := range current.Outflows </span><span class="cov8" title="1">{
                        inDegree[outflowID]--
                        if inDegree[outflowID] == 0 </span><span class="cov8" title="1">{
                                if task, exists := taskMap[outflowID]; exists </span><span class="cov8" title="1">{
                                        queue = append(queue, task)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

func (s *TaskService) checkInboxConstraint(ctx context.Context) error <span class="cov8" title="1">{
        inboxCount, err := s.repo.CountByStage(ctx, domain.StageInbox)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check inbox count: %w", err)
        }</span>

        <span class="cov8" title="1">if inboxCount &gt;= s.maxInboxSize </span><span class="cov0" title="0">{
                return fmt.Errorf("inbox is full (%d tasks), cannot perform operation until resolved", inboxCount)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *TaskService) checkDependencies(ctx context.Context, task *domain.Task) error <span class="cov8" title="1">{
        if len(task.Inflows) == 0 </span><span class="cov8" title="1">{
                return nil // No dependencies
        }</span>

        <span class="cov8" title="1">dependencies, err := s.repo.GetTasksByIDs(ctx, task.Inflows)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check dependencies: %w", err)
        }</span>

        <span class="cov8" title="1">for _, dep := range dependencies </span><span class="cov8" title="1">{
                if dep.Status != domain.StatusCompleted </span><span class="cov8" title="1">{
                        return fmt.Errorf("dependency %s is not completed", dep.ID)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *TaskService) validateSameChain(ctx context.Context, task1, task2 *domain.Task) error <span class="cov8" title="1">{
        // Simple validation - ensure they're in the same location hierarchy
        if len(task1.Location) != len(task2.Location) </span><span class="cov0" title="0">{
                return fmt.Errorf("tasks are not in the same chain")
        }</span>

        <span class="cov8" title="1">for i, loc := range task1.Location </span><span class="cov8" title="1">{
                if task2.Location[i] != loc </span><span class="cov0" title="0">{
                        return fmt.Errorf("tasks are not in the same chain")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *TaskService) checkChainHopping(ctx context.Context, source, target *domain.Task) error <span class="cov8" title="1">{
        // Check if target is already transitively dependent on source
        if s.isTransitivelyDependent(ctx, target.ID, source.ID) </span><span class="cov0" title="0">{
                return fmt.Errorf("would create chain hopping: %s already depends on %s transitively", target.ID, source.ID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *TaskService) isTransitivelyDependent(ctx context.Context, taskID, dependencyID string) bool <span class="cov8" title="1">{
        visited := make(map[string]bool)
        return s.hasTransitiveDependency(ctx, taskID, dependencyID, visited)
}</span>

func (s *TaskService) hasTransitiveDependency(ctx context.Context, taskID, dependencyID string, visited map[string]bool) bool <span class="cov8" title="1">{
        if visited[taskID] </span><span class="cov0" title="0">{
                return false // Avoid cycles
        }</span>
        <span class="cov8" title="1">visited[taskID] = true

        task, err := s.repo.GetByID(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, inflowID := range task.Inflows </span><span class="cov0" title="0">{
                if inflowID == dependencyID </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if s.hasTransitiveDependency(ctx, inflowID, dependencyID, visited) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (s *TaskService) updateDependenciesForMerge(ctx context.Context, fromTask, toTask *domain.Task) error <span class="cov8" title="1">{
        // Update tasks that depend on fromTask to depend on toTask instead
        for _, outflowID := range fromTask.Outflows </span><span class="cov0" title="0">{
                outflowTask, err := s.repo.GetByID(ctx, outflowID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip if not found
                }

                // Replace fromTask.ID with toTask.ID in inflows
                <span class="cov0" title="0">for i, inflowID := range outflowTask.Inflows </span><span class="cov0" title="0">{
                        if inflowID == fromTask.ID </span><span class="cov0" title="0">{
                                outflowTask.Inflows[i] = toTask.ID
                                break</span>
                        }
                }

                <span class="cov0" title="0">if err := s.repo.Update(ctx, outflowTask); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update outflow task %s: %w", outflowID, err)
                }</span>
        }

        // Update toTask's outflows to include fromTask's outflows
        <span class="cov8" title="1">for _, outflowID := range fromTask.Outflows </span><span class="cov0" title="0">{
                if !contains(toTask.Outflows, outflowID) </span><span class="cov0" title="0">{
                        toTask.Outflows = append(toTask.Outflows, outflowID)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *TaskService) updateDependenciesForSplit(ctx context.Context, originalTask *domain.Task, newTasks []*domain.Task) error <span class="cov8" title="1">{
        // For simplicity, make the first new task inherit all dependencies
        if len(newTasks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">firstTask := newTasks[0]
        firstTask.Inflows = originalTask.Inflows
        firstTask.Outflows = originalTask.Outflows

        // Update tasks that depended on the original to depend on the first new task
        for _, outflowID := range originalTask.Outflows </span><span class="cov0" title="0">{
                outflowTask, err := s.repo.GetByID(ctx, outflowID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for i, inflowID := range outflowTask.Inflows </span><span class="cov0" title="0">{
                        if inflowID == originalTask.ID </span><span class="cov0" title="0">{
                                outflowTask.Inflows[i] = firstTask.ID
                                break</span>
                        }
                }

                <span class="cov0" title="0">if err := s.repo.Update(ctx, outflowTask); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update outflow task %s: %w", outflowID, err)
                }</span>
        }

        // Update tasks that the original depended on
        <span class="cov8" title="1">for _, inflowID := range originalTask.Inflows </span><span class="cov0" title="0">{
                inflowTask, err := s.repo.GetByID(ctx, inflowID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for i, outflowID := range inflowTask.Outflows </span><span class="cov0" title="0">{
                        if outflowID == originalTask.ID </span><span class="cov0" title="0">{
                                inflowTask.Outflows[i] = firstTask.ID
                                break</span>
                        }
                }

                <span class="cov0" title="0">if err := s.repo.Update(ctx, inflowTask); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update inflow task %s: %w", inflowID, err)
                }</span>
        }

        // Update first task
        <span class="cov8" title="1">if err := s.repo.Update(ctx, firstTask); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update first new task: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.31.1
// source: task.proto

package v1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TaskStage defines the lifecycle stages of a task.
type TaskStage int32

const (
        TaskStage_STAGE_UNSPECIFIED TaskStage = 0
        TaskStage_STAGE_PENDING     TaskStage = 1
        TaskStage_STAGE_INBOX       TaskStage = 2
        TaskStage_STAGE_STAGING     TaskStage = 3
        TaskStage_STAGE_ACTIVE      TaskStage = 4
        // Note: ARCHIVED tasks technically leave this system, but we might keep
        // a reference or status for internal logic before full removal.
        TaskStage_STAGE_ARCHIVED TaskStage = 5
)

// Enum value maps for TaskStage.
var (
        TaskStage_name = map[int32]string{
                0: "STAGE_UNSPECIFIED",
                1: "STAGE_PENDING",
                2: "STAGE_INBOX",
                3: "STAGE_STAGING",
                4: "STAGE_ACTIVE",
                5: "STAGE_ARCHIVED",
        }
        TaskStage_value = map[string]int32{
                "STAGE_UNSPECIFIED": 0,
                "STAGE_PENDING":     1,
                "STAGE_INBOX":       2,
                "STAGE_STAGING":     3,
                "STAGE_ACTIVE":      4,
                "STAGE_ARCHIVED":    5,
        }
)

func (x TaskStage) Enum() *TaskStage <span class="cov0" title="0">{
        p := new(TaskStage)
        *p = x
        return p
}</span>

func (x TaskStage) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TaskStage) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_task_proto_enumTypes[0].Descriptor()
}</span>

func (TaskStage) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_task_proto_enumTypes[0]
}</span>

func (x TaskStage) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TaskStage.Descriptor instead.
func (TaskStage) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{0}
}</span>

// TaskStatus defines the detailed status within a stage.
type TaskStatus int32

const (
        TaskStatus_TASK_STATUS_UNSPECIFIED TaskStatus = 0 // Default, unset value
        TaskStatus_TASK_STATUS_TODO        TaskStatus = 1
        TaskStatus_TASK_STATUS_IN_PROGRESS TaskStatus = 2
        TaskStatus_TASK_STATUS_PAUSED      TaskStatus = 3
        TaskStatus_TASK_STATUS_BLOCKED     TaskStatus = 4
        TaskStatus_TASK_STATUS_COMPLETED   TaskStatus = 5
        TaskStatus_TASK_STATUS_CANCELLED   TaskStatus = 6
)

// Enum value maps for TaskStatus.
var (
        TaskStatus_name = map[int32]string{
                0: "TASK_STATUS_UNSPECIFIED",
                1: "TASK_STATUS_TODO",
                2: "TASK_STATUS_IN_PROGRESS",
                3: "TASK_STATUS_PAUSED",
                4: "TASK_STATUS_BLOCKED",
                5: "TASK_STATUS_COMPLETED",
                6: "TASK_STATUS_CANCELLED",
        }
        TaskStatus_value = map[string]int32{
                "TASK_STATUS_UNSPECIFIED": 0,
                "TASK_STATUS_TODO":        1,
                "TASK_STATUS_IN_PROGRESS": 2,
                "TASK_STATUS_PAUSED":      3,
                "TASK_STATUS_BLOCKED":     4,
                "TASK_STATUS_COMPLETED":   5,
                "TASK_STATUS_CANCELLED":   6,
        }
)

func (x TaskStatus) Enum() *TaskStatus <span class="cov0" title="0">{
        p := new(TaskStatus)
        *p = x
        return p
}</span>

func (x TaskStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TaskStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_task_proto_enumTypes[1].Descriptor()
}</span>

func (TaskStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_task_proto_enumTypes[1]
}</span>

func (x TaskStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TaskStatus.Descriptor instead.
func (TaskStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{1}
}</span>

// Tag types for dynamic typing
type TagType int32

const (
        TagType_TAG_TYPE_UNSPECIFIED TagType = 0
        TagType_TAG_TYPE_TEXT        TagType = 1
        TagType_TAG_TYPE_LOCATION    TagType = 2
        TagType_TAG_TYPE_TIME        TagType = 3
)

// Enum value maps for TagType.
var (
        TagType_name = map[int32]string{
                0: "TAG_TYPE_UNSPECIFIED",
                1: "TAG_TYPE_TEXT",
                2: "TAG_TYPE_LOCATION",
                3: "TAG_TYPE_TIME",
        }
        TagType_value = map[string]int32{
                "TAG_TYPE_UNSPECIFIED": 0,
                "TAG_TYPE_TEXT":        1,
                "TAG_TYPE_LOCATION":    2,
                "TAG_TYPE_TIME":        3,
        }
)

func (x TagType) Enum() *TagType <span class="cov0" title="0">{
        p := new(TagType)
        *p = x
        return p
}</span>

func (x TagType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TagType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_task_proto_enumTypes[2].Descriptor()
}</span>

func (TagType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_task_proto_enumTypes[2]
}</span>

func (x TagType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TagType.Descriptor instead.
func (TagType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{2}
}</span>

// Notification types
type NotificationType int32

const (
        NotificationType_NOTIFICATION_TYPE_UNSPECIFIED  NotificationType = 0
        NotificationType_NOTIFICATION_ON_ASSIGN         NotificationType = 1
        NotificationType_NOTIFICATION_ON_START          NotificationType = 2
        NotificationType_NOTIFICATION_N_DAYS_BEFORE_DUE NotificationType = 3
)

// Enum value maps for NotificationType.
var (
        NotificationType_name = map[int32]string{
                0: "NOTIFICATION_TYPE_UNSPECIFIED",
                1: "NOTIFICATION_ON_ASSIGN",
                2: "NOTIFICATION_ON_START",
                3: "NOTIFICATION_N_DAYS_BEFORE_DUE",
        }
        NotificationType_value = map[string]int32{
                "NOTIFICATION_TYPE_UNSPECIFIED":  0,
                "NOTIFICATION_ON_ASSIGN":         1,
                "NOTIFICATION_ON_START":          2,
                "NOTIFICATION_N_DAYS_BEFORE_DUE": 3,
        }
)

func (x NotificationType) Enum() *NotificationType <span class="cov0" title="0">{
        p := new(NotificationType)
        *p = x
        return p
}</span>

func (x NotificationType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (NotificationType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_task_proto_enumTypes[3].Descriptor()
}</span>

func (NotificationType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_task_proto_enumTypes[3]
}</span>

func (x NotificationType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use NotificationType.Descriptor instead.
func (NotificationType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{3}
}</span>

// User information
type User struct {
        state                protoimpl.MessageState `protogen:"open.v1"`
        Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Email                string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Name                 string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        GoogleCalendarToken  string                 `protobuf:"bytes,4,opt,name=google_calendar_token,json=googleCalendarToken,proto3" json:"google_calendar_token,omitempty"`
        NotificationSettings []*NotificationSetting `protobuf:"bytes,5,rep,name=notification_settings,json=notificationSettings,proto3" json:"notification_settings,omitempty"`
        unknownFields        protoimpl.UnknownFields
        sizeCache            protoimpl.SizeCache
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_task_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{0}
}</span>

func (x *User) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetGoogleCalendarToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GoogleCalendarToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetNotificationSettings() []*NotificationSetting <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NotificationSettings
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Notification settings per user
type NotificationSetting struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Type          NotificationType       `protobuf:"varint,1,opt,name=type,proto3,enum=taskcore.v1.NotificationType" json:"type,omitempty"`
        Enabled       bool                   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
        DaysBefore    int32                  `protobuf:"varint,3,opt,name=days_before,json=daysBefore,proto3" json:"days_before,omitempty"` // For N_DAYS_BEFORE_DUE type
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NotificationSetting) Reset() <span class="cov0" title="0">{
        *x = NotificationSetting{}
        mi := &amp;file_task_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NotificationSetting) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NotificationSetting) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NotificationSetting) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NotificationSetting.ProtoReflect.Descriptor instead.
func (*NotificationSetting) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{1}
}</span>

func (x *NotificationSetting) GetType() NotificationType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return NotificationType_NOTIFICATION_TYPE_UNSPECIFIED</span>
}

func (x *NotificationSetting) GetEnabled() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *NotificationSetting) GetDaysBefore() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DaysBefore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Typed tag value
type TagValue struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        Type  TagType                `protobuf:"varint,1,opt,name=type,proto3,enum=taskcore.v1.TagType" json:"type,omitempty"`
        // Types that are valid to be assigned to Value:
        //
        //        *TagValue_TextValue
        //        *TagValue_LocationValue
        //        *TagValue_TimeValue
        Value         isTagValue_Value `protobuf_oneof:"value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TagValue) Reset() <span class="cov0" title="0">{
        *x = TagValue{}
        mi := &amp;file_task_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TagValue) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TagValue) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TagValue) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TagValue.ProtoReflect.Descriptor instead.
func (*TagValue) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{2}
}</span>

func (x *TagValue) GetType() TagType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TagType_TAG_TYPE_UNSPECIFIED</span>
}

func (x *TagValue) GetValue() isTagValue_Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TagValue) GetTextValue() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Value.(*TagValue_TextValue); ok </span><span class="cov0" title="0">{
                        return x.TextValue
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (x *TagValue) GetLocationValue() *GeographicLocation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Value.(*TagValue_LocationValue); ok </span><span class="cov0" title="0">{
                        return x.LocationValue
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *TagValue) GetTimeValue() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Value.(*TagValue_TimeValue); ok </span><span class="cov0" title="0">{
                        return x.TimeValue
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isTagValue_Value interface {
        isTagValue_Value()
}

type TagValue_TextValue struct {
        TextValue string `protobuf:"bytes,2,opt,name=text_value,json=textValue,proto3,oneof"`
}

type TagValue_LocationValue struct {
        LocationValue *GeographicLocation `protobuf:"bytes,3,opt,name=location_value,json=locationValue,proto3,oneof"`
}

type TagValue_TimeValue struct {
        TimeValue *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=time_value,json=timeValue,proto3,oneof"`
}

func (*TagValue_TextValue) isTagValue_Value() {<span class="cov0" title="0">}</span>

func (*TagValue_LocationValue) isTagValue_Value() {<span class="cov0" title="0">}</span>

func (*TagValue_TimeValue) isTagValue_Value() {<span class="cov0" title="0">}</span>

// Geographic location for location tags
type GeographicLocation struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Latitude      float64                `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude     float64                `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
        Address       string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GeographicLocation) Reset() <span class="cov0" title="0">{
        *x = GeographicLocation{}
        mi := &amp;file_task_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GeographicLocation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GeographicLocation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GeographicLocation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GeographicLocation.ProtoReflect.Descriptor instead.
func (*GeographicLocation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GeographicLocation) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GeographicLocation) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GeographicLocation) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Point pair for tracking work
type Point struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        Value         uint32                 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Point) Reset() <span class="cov0" title="0">{
        *x = Point{}
        mi := &amp;file_task_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Point) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Point) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Point) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Point.ProtoReflect.Descriptor instead.
func (*Point) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Point) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Point) GetValue() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Work interval for scheduling
type WorkInterval struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Start           *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
        Stop            *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=stop,proto3" json:"stop,omitempty"`
        PointsCompleted []*Point               `protobuf:"bytes,3,rep,name=points_completed,json=pointsCompleted,proto3" json:"points_completed,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *WorkInterval) Reset() <span class="cov0" title="0">{
        *x = WorkInterval{}
        mi := &amp;file_task_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *WorkInterval) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WorkInterval) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WorkInterval) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WorkInterval.ProtoReflect.Descriptor instead.
func (*WorkInterval) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{5}
}</span>

func (x *WorkInterval) GetStart() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Start
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WorkInterval) GetStop() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stop
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WorkInterval) GetPointsCompleted() []*Point <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PointsCompleted
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Schedule information
type Schedule struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        WorkIntervals []*WorkInterval        `protobuf:"bytes,1,rep,name=work_intervals,json=workIntervals,proto3" json:"work_intervals,omitempty"`
        Due           *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=due,proto3" json:"due,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Schedule) Reset() <span class="cov0" title="0">{
        *x = Schedule{}
        mi := &amp;file_task_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Schedule) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Schedule) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Schedule) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Schedule.ProtoReflect.Descriptor instead.
func (*Schedule) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{6}
}</span>

func (x *Schedule) GetWorkIntervals() []*WorkInterval <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WorkIntervals
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schedule) GetDue() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Due
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Status update
type StatusUpdate struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Time          *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
        Update        string                 `protobuf:"bytes,2,opt,name=update,proto3" json:"update,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatusUpdate) Reset() <span class="cov0" title="0">{
        *x = StatusUpdate{}
        mi := &amp;file_task_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatusUpdate) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatusUpdate) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatusUpdate) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatusUpdate.ProtoReflect.Descriptor instead.
func (*StatusUpdate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{7}
}</span>

func (x *StatusUpdate) GetTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Time
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StatusUpdate) GetUpdate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Update
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Status tracking
type Status struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Updates       []*StatusUpdate        `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Status) Reset() <span class="cov0" title="0">{
        *x = Status{}
        mi := &amp;file_task_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Status) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Status) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Status) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Status.ProtoReflect.Descriptor instead.
func (*Status) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{8}
}</span>

func (x *Status) GetUpdates() []*StatusUpdate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Updates
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Task represents a single unit of work in the system.
type Task struct {
        state                 protoimpl.MessageState `protogen:"open.v1"`
        Id                    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name                  string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Description           string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Stage                 TaskStage              `protobuf:"varint,4,opt,name=stage,proto3,enum=taskcore.v1.TaskStage" json:"stage,omitempty"`
        Location              []string               `protobuf:"bytes,5,rep,name=location,proto3" json:"location,omitempty"` // hierarchical path
        Points                []*Point               `protobuf:"bytes,6,rep,name=points,proto3" json:"points,omitempty"`
        Schedule              *Schedule              `protobuf:"bytes,7,opt,name=schedule,proto3" json:"schedule,omitempty"`
        Status                *Status                `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
        Tags                  map[string]*TagValue   `protobuf:"bytes,9,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // user configurable with types
        Inflows               []string               `protobuf:"bytes,10,rep,name=inflows,proto3" json:"inflows,omitempty"`                                                                    // task IDs this depends on
        Outflows              []string               `protobuf:"bytes,11,rep,name=outflows,proto3" json:"outflows,omitempty"`                                                                  // task IDs that depend on this
        UserId                string                 `protobuf:"bytes,12,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`                                                        // owner of the task
        GoogleCalendarEventId string                 `protobuf:"bytes,13,opt,name=google_calendar_event_id,json=googleCalendarEventId,proto3" json:"google_calendar_event_id,omitempty"`       // for calendar sync
        unknownFields         protoimpl.UnknownFields
        sizeCache             protoimpl.SizeCache
}

func (x *Task) Reset() <span class="cov0" title="0">{
        *x = Task{}
        mi := &amp;file_task_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Task) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Task) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Task) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Task.ProtoReflect.Descriptor instead.
func (*Task) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{9}
}</span>

func (x *Task) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetStage() TaskStage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stage
        }</span>
        <span class="cov0" title="0">return TaskStage_STAGE_UNSPECIFIED</span>
}

func (x *Task) GetLocation() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetPoints() []*Point <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Points
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetSchedule() *Schedule <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schedule
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetStatus() *Status <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetTags() map[string]*TagValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetInflows() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Inflows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetOutflows() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Outflows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Task) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Task) GetGoogleCalendarEventId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GoogleCalendarEventId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Request/Response messages
type AddTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Description   string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        UserId        string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddTaskRequest) Reset() <span class="cov0" title="0">{
        *x = AddTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddTaskRequest.ProtoReflect.Descriptor instead.
func (*AddTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{10}
}</span>

func (x *AddTaskRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddTaskRequest) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddTaskRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddTaskResponse) Reset() <span class="cov0" title="0">{
        *x = AddTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddTaskResponse.ProtoReflect.Descriptor instead.
func (*AddTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{11}
}</span>

func (x *AddTaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateTaskTagsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Tags          map[string]*TagValue   `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateTaskTagsRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateTaskTagsRequest{}
        mi := &amp;file_task_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateTaskTagsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTaskTagsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTaskTagsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTaskTagsRequest.ProtoReflect.Descriptor instead.
func (*UpdateTaskTagsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{12}
}</span>

func (x *UpdateTaskTagsRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTaskTagsRequest) GetTags() map[string]*TagValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateTaskTagsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateTaskTagsResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateTaskTagsResponse{}
        mi := &amp;file_task_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateTaskTagsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTaskTagsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTaskTagsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTaskTagsResponse.ProtoReflect.Descriptor instead.
func (*UpdateTaskTagsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{13}
}</span>

func (x *UpdateTaskTagsResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SyncCalendarRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SyncCalendarRequest) Reset() <span class="cov0" title="0">{
        *x = SyncCalendarRequest{}
        mi := &amp;file_task_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SyncCalendarRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SyncCalendarRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SyncCalendarRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SyncCalendarRequest.ProtoReflect.Descriptor instead.
func (*SyncCalendarRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{14}
}</span>

func (x *SyncCalendarRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SyncCalendarResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TasksSynced   int32                  `protobuf:"varint,1,opt,name=tasks_synced,json=tasksSynced,proto3" json:"tasks_synced,omitempty"`
        Errors        []string               `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SyncCalendarResponse) Reset() <span class="cov0" title="0">{
        *x = SyncCalendarResponse{}
        mi := &amp;file_task_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SyncCalendarResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SyncCalendarResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SyncCalendarResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SyncCalendarResponse.ProtoReflect.Descriptor instead.
func (*SyncCalendarResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{15}
}</span>

func (x *SyncCalendarResponse) GetTasksSynced() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TasksSynced
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SyncCalendarResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        mi := &amp;file_task_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetUserRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserResponse{}
        mi := &amp;file_task_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserResponse.ProtoReflect.Descriptor instead.
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{17}
}</span>

func (x *GetUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateUserRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateUserRequest{}
        mi := &amp;file_task_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{18}
}</span>

func (x *UpdateUserRequest) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateUserResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateUserResponse{}
        mi := &amp;file_task_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserResponse.ProtoReflect.Descriptor instead.
func (*UpdateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{19}
}</span>

func (x *UpdateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MoveToStagingRequest struct {
        state    protoimpl.MessageState `protogen:"open.v1"`
        SourceId string                 `protobuf:"bytes,1,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
        // Types that are valid to be assigned to Destination:
        //
        //        *MoveToStagingRequest_DestinationId
        //        *MoveToStagingRequest_NewLocation
        Destination   isMoveToStagingRequest_Destination `protobuf_oneof:"destination"`
        Points        []*Point                           `protobuf:"bytes,4,rep,name=points,proto3" json:"points,omitempty"`
        Tags          map[string]*TagValue               `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // tags to add during staging
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MoveToStagingRequest) Reset() <span class="cov0" title="0">{
        *x = MoveToStagingRequest{}
        mi := &amp;file_task_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MoveToStagingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MoveToStagingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MoveToStagingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MoveToStagingRequest.ProtoReflect.Descriptor instead.
func (*MoveToStagingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{20}
}</span>

func (x *MoveToStagingRequest) GetSourceId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MoveToStagingRequest) GetDestination() isMoveToStagingRequest_Destination <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MoveToStagingRequest) GetDestinationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Destination.(*MoveToStagingRequest_DestinationId); ok </span><span class="cov0" title="0">{
                        return x.DestinationId
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (x *MoveToStagingRequest) GetNewLocation() *MoveToStagingRequest_NewLocationList <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Destination.(*MoveToStagingRequest_NewLocation); ok </span><span class="cov0" title="0">{
                        return x.NewLocation
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *MoveToStagingRequest) GetPoints() []*Point <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Points
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MoveToStagingRequest) GetTags() map[string]*TagValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isMoveToStagingRequest_Destination interface {
        isMoveToStagingRequest_Destination()
}

type MoveToStagingRequest_DestinationId struct {
        DestinationId string `protobuf:"bytes,2,opt,name=destination_id,json=destinationId,proto3,oneof"`
}

type MoveToStagingRequest_NewLocation struct {
        NewLocation *MoveToStagingRequest_NewLocationList `protobuf:"bytes,3,opt,name=new_location,json=newLocation,proto3,oneof"`
}

func (*MoveToStagingRequest_DestinationId) isMoveToStagingRequest_Destination() {<span class="cov0" title="0">}</span>

func (*MoveToStagingRequest_NewLocation) isMoveToStagingRequest_Destination() {<span class="cov0" title="0">}</span>

type MoveToStagingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MoveToStagingResponse) Reset() <span class="cov0" title="0">{
        *x = MoveToStagingResponse{}
        mi := &amp;file_task_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MoveToStagingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MoveToStagingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MoveToStagingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MoveToStagingResponse.ProtoReflect.Descriptor instead.
func (*MoveToStagingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{21}
}</span>

func (x *MoveToStagingResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StartTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StartTaskRequest) Reset() <span class="cov0" title="0">{
        *x = StartTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StartTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StartTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StartTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StartTaskRequest.ProtoReflect.Descriptor instead.
func (*StartTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{22}
}</span>

func (x *StartTaskRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StartTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StartTaskResponse) Reset() <span class="cov0" title="0">{
        *x = StartTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StartTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StartTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StartTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StartTaskResponse.ProtoReflect.Descriptor instead.
func (*StartTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{23}
}</span>

func (x *StartTaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StopTaskRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        PointsCompleted []*Point               `protobuf:"bytes,2,rep,name=points_completed,json=pointsCompleted,proto3" json:"points_completed,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *StopTaskRequest) Reset() <span class="cov0" title="0">{
        *x = StopTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StopTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StopTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StopTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StopTaskRequest.ProtoReflect.Descriptor instead.
func (*StopTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{24}
}</span>

func (x *StopTaskRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StopTaskRequest) GetPointsCompleted() []*Point <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PointsCompleted
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StopTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        Completed     bool                   `protobuf:"varint,2,opt,name=completed,proto3" json:"completed,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StopTaskResponse) Reset() <span class="cov0" title="0">{
        *x = StopTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StopTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StopTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StopTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StopTaskResponse.ProtoReflect.Descriptor instead.
func (*StopTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{25}
}</span>

func (x *StopTaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StopTaskResponse) GetCompleted() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Completed
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CompleteTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CompleteTaskRequest) Reset() <span class="cov0" title="0">{
        *x = CompleteTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[26]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CompleteTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CompleteTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CompleteTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[26]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CompleteTaskRequest.ProtoReflect.Descriptor instead.
func (*CompleteTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{26}
}</span>

func (x *CompleteTaskRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CompleteTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CompleteTaskResponse) Reset() <span class="cov0" title="0">{
        *x = CompleteTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CompleteTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CompleteTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CompleteTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CompleteTaskResponse.ProtoReflect.Descriptor instead.
func (*CompleteTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{27}
}</span>

func (x *CompleteTaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MergeTasksRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        FromId        string                 `protobuf:"bytes,1,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
        ToId          string                 `protobuf:"bytes,2,opt,name=to_id,json=toId,proto3" json:"to_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MergeTasksRequest) Reset() <span class="cov0" title="0">{
        *x = MergeTasksRequest{}
        mi := &amp;file_task_proto_msgTypes[28]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MergeTasksRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MergeTasksRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MergeTasksRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[28]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MergeTasksRequest.ProtoReflect.Descriptor instead.
func (*MergeTasksRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{28}
}</span>

func (x *MergeTasksRequest) GetFromId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MergeTasksRequest) GetToId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MergeTasksResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        MergedTask    *Task                  `protobuf:"bytes,1,opt,name=merged_task,json=mergedTask,proto3" json:"merged_task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MergeTasksResponse) Reset() <span class="cov0" title="0">{
        *x = MergeTasksResponse{}
        mi := &amp;file_task_proto_msgTypes[29]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MergeTasksResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MergeTasksResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MergeTasksResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[29]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MergeTasksResponse.ProtoReflect.Descriptor instead.
func (*MergeTasksResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{29}
}</span>

func (x *MergeTasksResponse) GetMergedTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MergedTask
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SplitTaskRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        NewNames        []string               `protobuf:"bytes,2,rep,name=new_names,json=newNames,proto3" json:"new_names,omitempty"`
        NewDescriptions []string               `protobuf:"bytes,3,rep,name=new_descriptions,json=newDescriptions,proto3" json:"new_descriptions,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *SplitTaskRequest) Reset() <span class="cov0" title="0">{
        *x = SplitTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[30]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SplitTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SplitTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SplitTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[30]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SplitTaskRequest.ProtoReflect.Descriptor instead.
func (*SplitTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{30}
}</span>

func (x *SplitTaskRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SplitTaskRequest) GetNewNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SplitTaskRequest) GetNewDescriptions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewDescriptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SplitTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NewTasks      []*Task                `protobuf:"bytes,1,rep,name=new_tasks,json=newTasks,proto3" json:"new_tasks,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SplitTaskResponse) Reset() <span class="cov0" title="0">{
        *x = SplitTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[31]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SplitTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SplitTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SplitTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[31]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SplitTaskResponse.ProtoReflect.Descriptor instead.
func (*SplitTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{31}
}</span>

func (x *SplitTaskResponse) GetNewTasks() []*Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewTasks
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AdvertiseTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        TargetIds     []string               `protobuf:"bytes,2,rep,name=target_ids,json=targetIds,proto3" json:"target_ids,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AdvertiseTaskRequest) Reset() <span class="cov0" title="0">{
        *x = AdvertiseTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[32]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AdvertiseTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AdvertiseTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AdvertiseTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[32]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AdvertiseTaskRequest.ProtoReflect.Descriptor instead.
func (*AdvertiseTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{32}
}</span>

func (x *AdvertiseTaskRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AdvertiseTaskRequest) GetTargetIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TargetIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AdvertiseTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AdvertiseTaskResponse) Reset() <span class="cov0" title="0">{
        *x = AdvertiseTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[33]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AdvertiseTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AdvertiseTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AdvertiseTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[33]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AdvertiseTaskResponse.ProtoReflect.Descriptor instead.
func (*AdvertiseTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{33}
}</span>

func (x *AdvertiseTaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StitchTasksRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        SourceIds     []string               `protobuf:"bytes,1,rep,name=source_ids,json=sourceIds,proto3" json:"source_ids,omitempty"`
        TargetId      string                 `protobuf:"bytes,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StitchTasksRequest) Reset() <span class="cov0" title="0">{
        *x = StitchTasksRequest{}
        mi := &amp;file_task_proto_msgTypes[34]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StitchTasksRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StitchTasksRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StitchTasksRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[34]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StitchTasksRequest.ProtoReflect.Descriptor instead.
func (*StitchTasksRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{34}
}</span>

func (x *StitchTasksRequest) GetSourceIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StitchTasksRequest) GetTargetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TargetId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StitchTasksResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UpdatedTasks  []*Task                `protobuf:"bytes,1,rep,name=updated_tasks,json=updatedTasks,proto3" json:"updated_tasks,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StitchTasksResponse) Reset() <span class="cov0" title="0">{
        *x = StitchTasksResponse{}
        mi := &amp;file_task_proto_msgTypes[35]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StitchTasksResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StitchTasksResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StitchTasksResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[35]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StitchTasksResponse.ProtoReflect.Descriptor instead.
func (*StitchTasksResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{35}
}</span>

func (x *StitchTasksResponse) GetUpdatedTasks() []*Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedTasks
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTasksRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Stage         TaskStage              `protobuf:"varint,1,opt,name=stage,proto3,enum=taskcore.v1.TaskStage" json:"stage,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListTasksRequest) Reset() <span class="cov0" title="0">{
        *x = ListTasksRequest{}
        mi := &amp;file_task_proto_msgTypes[36]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListTasksRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTasksRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTasksRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[36]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTasksRequest.ProtoReflect.Descriptor instead.
func (*ListTasksRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{36}
}</span>

func (x *ListTasksRequest) GetStage() TaskStage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stage
        }</span>
        <span class="cov0" title="0">return TaskStage_STAGE_UNSPECIFIED</span>
}

type ListTasksResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Tasks         []*Task                `protobuf:"bytes,1,rep,name=tasks,proto3" json:"tasks,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListTasksResponse) Reset() <span class="cov0" title="0">{
        *x = ListTasksResponse{}
        mi := &amp;file_task_proto_msgTypes[37]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListTasksResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListTasksResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListTasksResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[37]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListTasksResponse.ProtoReflect.Descriptor instead.
func (*ListTasksResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{37}
}</span>

func (x *ListTasksResponse) GetTasks() []*Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tasks
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetTaskRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskRequest) Reset() <span class="cov0" title="0">{
        *x = GetTaskRequest{}
        mi := &amp;file_task_proto_msgTypes[38]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[38]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskRequest.ProtoReflect.Descriptor instead.
func (*GetTaskRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{38}
}</span>

func (x *GetTaskRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTaskResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Task          *Task                  `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTaskResponse) Reset() <span class="cov0" title="0">{
        *x = GetTaskResponse{}
        mi := &amp;file_task_proto_msgTypes[39]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTaskResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTaskResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTaskResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[39]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTaskResponse.ProtoReflect.Descriptor instead.
func (*GetTaskResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{39}
}</span>

func (x *GetTaskResponse) GetTask() *Task <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Task
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MoveToStagingRequest_NewLocationList struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        NewLocation   []string               `protobuf:"bytes,1,rep,name=new_location,json=newLocation,proto3" json:"new_location,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MoveToStagingRequest_NewLocationList) Reset() <span class="cov0" title="0">{
        *x = MoveToStagingRequest_NewLocationList{}
        mi := &amp;file_task_proto_msgTypes[43]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MoveToStagingRequest_NewLocationList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MoveToStagingRequest_NewLocationList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MoveToStagingRequest_NewLocationList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_task_proto_msgTypes[43]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MoveToStagingRequest_NewLocationList.ProtoReflect.Descriptor instead.
func (*MoveToStagingRequest_NewLocationList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_task_proto_rawDescGZIP(), []int{20, 1}
}</span>

func (x *MoveToStagingRequest_NewLocationList) GetNewLocation() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_task_proto protoreflect.FileDescriptor

const file_task_proto_rawDesc = "" +
        "\n" +
        "\n" +
        "task.proto\x12\vtaskcore.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xcb\x01\n" +
        "\x04User\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
        "\x05email\x18\x02 \x01(\tR\x05email\x12\x12\n" +
        "\x04name\x18\x03 \x01(\tR\x04name\x122\n" +
        "\x15google_calendar_token\x18\x04 \x01(\tR\x13googleCalendarToken\x12U\n" +
        "\x15notification_settings\x18\x05 \x03(\v2 .taskcore.v1.NotificationSettingR\x14notificationSettings\"\x83\x01\n" +
        "\x13NotificationSetting\x121\n" +
        "\x04type\x18\x01 \x01(\x0e2\x1d.taskcore.v1.NotificationTypeR\x04type\x12\x18\n" +
        "\aenabled\x18\x02 \x01(\bR\aenabled\x12\x1f\n" +
        "\vdays_before\x18\x03 \x01(\x05R\n" +
        "daysBefore\"\xe5\x01\n" +
        "\bTagValue\x12(\n" +
        "\x04type\x18\x01 \x01(\x0e2\x14.taskcore.v1.TagTypeR\x04type\x12\x1f\n" +
        "\n" +
        "text_value\x18\x02 \x01(\tH\x00R\ttextValue\x12H\n" +
        "\x0elocation_value\x18\x03 \x01(\v2\x1f.taskcore.v1.GeographicLocationH\x00R\rlocationValue\x12;\n" +
        "\n" +
        "time_value\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\ttimeValueB\a\n" +
        "\x05value\"h\n" +
        "\x12GeographicLocation\x12\x1a\n" +
        "\blatitude\x18\x01 \x01(\x01R\blatitude\x12\x1c\n" +
        "\tlongitude\x18\x02 \x01(\x01R\tlongitude\x12\x18\n" +
        "\aaddress\x18\x03 \x01(\tR\aaddress\"3\n" +
        "\x05Point\x12\x14\n" +
        "\x05title\x18\x01 \x01(\tR\x05title\x12\x14\n" +
        "\x05value\x18\x02 \x01(\rR\x05value\"\xaf\x01\n" +
        "\fWorkInterval\x120\n" +
        "\x05start\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x05start\x12.\n" +
        "\x04stop\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x04stop\x12=\n" +
        "\x10points_completed\x18\x03 \x03(\v2\x12.taskcore.v1.PointR\x0fpointsCompleted\"z\n" +
        "\bSchedule\x12@\n" +
        "\x0ework_intervals\x18\x01 \x03(\v2\x19.taskcore.v1.WorkIntervalR\rworkIntervals\x12,\n" +
        "\x03due\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x03due\"V\n" +
        "\fStatusUpdate\x12.\n" +
        "\x04time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12\x16\n" +
        "\x06update\x18\x02 \x01(\tR\x06update\"=\n" +
        "\x06Status\x123\n" +
        "\aupdates\x18\x01 \x03(\v2\x19.taskcore.v1.StatusUpdateR\aupdates\"\xab\x04\n" +
        "\x04Task\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
        "\vdescription\x18\x03 \x01(\tR\vdescription\x12,\n" +
        "\x05stage\x18\x04 \x01(\x0e2\x16.taskcore.v1.TaskStageR\x05stage\x12\x1a\n" +
        "\blocation\x18\x05 \x03(\tR\blocation\x12*\n" +
        "\x06points\x18\x06 \x03(\v2\x12.taskcore.v1.PointR\x06points\x121\n" +
        "\bschedule\x18\a \x01(\v2\x15.taskcore.v1.ScheduleR\bschedule\x12+\n" +
        "\x06status\x18\b \x01(\v2\x13.taskcore.v1.StatusR\x06status\x12/\n" +
        "\x04tags\x18\t \x03(\v2\x1b.taskcore.v1.Task.TagsEntryR\x04tags\x12\x18\n" +
        "\ainflows\x18\n" +
        " \x03(\tR\ainflows\x12\x1a\n" +
        "\boutflows\x18\v \x03(\tR\boutflows\x12\x17\n" +
        "\auser_id\x18\f \x01(\tR\x06userId\x127\n" +
        "\x18google_calendar_event_id\x18\r \x01(\tR\x15googleCalendarEventId\x1aN\n" +
        "\tTagsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
        "\x05value\x18\x02 \x01(\v2\x15.taskcore.v1.TagValueR\x05value:\x028\x01\"_\n" +
        "\x0eAddTaskRequest\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
        "\vdescription\x18\x02 \x01(\tR\vdescription\x12\x17\n" +
        "\auser_id\x18\x03 \x01(\tR\x06userId\"8\n" +
        "\x0fAddTaskResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\"\xb9\x01\n" +
        "\x15UpdateTaskTagsRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12@\n" +
        "\x04tags\x18\x02 \x03(\v2,.taskcore.v1.UpdateTaskTagsRequest.TagsEntryR\x04tags\x1aN\n" +
        "\tTagsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
        "\x05value\x18\x02 \x01(\v2\x15.taskcore.v1.TagValueR\x05value:\x028\x01\"?\n" +
        "\x16UpdateTaskTagsResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\".\n" +
        "\x13SyncCalendarRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\"Q\n" +
        "\x14SyncCalendarResponse\x12!\n" +
        "\ftasks_synced\x18\x01 \x01(\x05R\vtasksSynced\x12\x16\n" +
        "\x06errors\x18\x02 \x03(\tR\x06errors\")\n" +
        "\x0eGetUserRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\"8\n" +
        "\x0fGetUserResponse\x12%\n" +
        "\x04user\x18\x01 \x01(\v2\x11.taskcore.v1.UserR\x04user\":\n" +
        "\x11UpdateUserRequest\x12%\n" +
        "\x04user\x18\x01 \x01(\v2\x11.taskcore.v1.UserR\x04user\";\n" +
        "\x12UpdateUserResponse\x12%\n" +
        "\x04user\x18\x01 \x01(\v2\x11.taskcore.v1.UserR\x04user\"\xb6\x03\n" +
        "\x14MoveToStagingRequest\x12\x1b\n" +
        "\tsource_id\x18\x01 \x01(\tR\bsourceId\x12'\n" +
        "\x0edestination_id\x18\x02 \x01(\tH\x00R\rdestinationId\x12V\n" +
        "\fnew_location\x18\x03 \x01(\v21.taskcore.v1.MoveToStagingRequest.NewLocationListH\x00R\vnewLocation\x12*\n" +
        "\x06points\x18\x04 \x03(\v2\x12.taskcore.v1.PointR\x06points\x12?\n" +
        "\x04tags\x18\x05 \x03(\v2+.taskcore.v1.MoveToStagingRequest.TagsEntryR\x04tags\x1aN\n" +
        "\tTagsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12+\n" +
        "\x05value\x18\x02 \x01(\v2\x15.taskcore.v1.TagValueR\x05value:\x028\x01\x1a4\n" +
        "\x0fNewLocationList\x12!\n" +
        "\fnew_location\x18\x01 \x03(\tR\vnewLocationB\r\n" +
        "\vdestination\"&gt;\n" +
        "\x15MoveToStagingResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\"\"\n" +
        "\x10StartTaskRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\":\n" +
        "\x11StartTaskResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\"`\n" +
        "\x0fStopTaskRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12=\n" +
        "\x10points_completed\x18\x02 \x03(\v2\x12.taskcore.v1.PointR\x0fpointsCompleted\"W\n" +
        "\x10StopTaskResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\x12\x1c\n" +
        "\tcompleted\x18\x02 \x01(\bR\tcompleted\"%\n" +
        "\x13CompleteTaskRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"=\n" +
        "\x14CompleteTaskResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\"A\n" +
        "\x11MergeTasksRequest\x12\x17\n" +
        "\afrom_id\x18\x01 \x01(\tR\x06fromId\x12\x13\n" +
        "\x05to_id\x18\x02 \x01(\tR\x04toId\"H\n" +
        "\x12MergeTasksResponse\x122\n" +
        "\vmerged_task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\n" +
        "mergedTask\"j\n" +
        "\x10SplitTaskRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
        "\tnew_names\x18\x02 \x03(\tR\bnewNames\x12)\n" +
        "\x10new_descriptions\x18\x03 \x03(\tR\x0fnewDescriptions\"C\n" +
        "\x11SplitTaskResponse\x12.\n" +
        "\tnew_tasks\x18\x01 \x03(\v2\x11.taskcore.v1.TaskR\bnewTasks\"E\n" +
        "\x14AdvertiseTaskRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
        "\n" +
        "target_ids\x18\x02 \x03(\tR\ttargetIds\"&gt;\n" +
        "\x15AdvertiseTaskResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task\"P\n" +
        "\x12StitchTasksRequest\x12\x1d\n" +
        "\n" +
        "source_ids\x18\x01 \x03(\tR\tsourceIds\x12\x1b\n" +
        "\ttarget_id\x18\x02 \x01(\tR\btargetId\"M\n" +
        "\x13StitchTasksResponse\x126\n" +
        "\rupdated_tasks\x18\x01 \x03(\v2\x11.taskcore.v1.TaskR\fupdatedTasks\"@\n" +
        "\x10ListTasksRequest\x12,\n" +
        "\x05stage\x18\x01 \x01(\x0e2\x16.taskcore.v1.TaskStageR\x05stage\"&lt;\n" +
        "\x11ListTasksResponse\x12'\n" +
        "\x05tasks\x18\x01 \x03(\v2\x11.taskcore.v1.TaskR\x05tasks\" \n" +
        "\x0eGetTaskRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"8\n" +
        "\x0fGetTaskResponse\x12%\n" +
        "\x04task\x18\x01 \x01(\v2\x11.taskcore.v1.TaskR\x04task*\x7f\n" +
        "\tTaskStage\x12\x15\n" +
        "\x11STAGE_UNSPECIFIED\x10\x00\x12\x11\n" +
        "\rSTAGE_PENDING\x10\x01\x12\x0f\n" +
        "\vSTAGE_INBOX\x10\x02\x12\x11\n" +
        "\rSTAGE_STAGING\x10\x03\x12\x10\n" +
        "\fSTAGE_ACTIVE\x10\x04\x12\x12\n" +
        "\x0eSTAGE_ARCHIVED\x10\x05*\xc3\x01\n" +
        "\n" +
        "TaskStatus\x12\x1b\n" +
        "\x17TASK_STATUS_UNSPECIFIED\x10\x00\x12\x14\n" +
        "\x10TASK_STATUS_TODO\x10\x01\x12\x1b\n" +
        "\x17TASK_STATUS_IN_PROGRESS\x10\x02\x12\x16\n" +
        "\x12TASK_STATUS_PAUSED\x10\x03\x12\x17\n" +
        "\x13TASK_STATUS_BLOCKED\x10\x04\x12\x19\n" +
        "\x15TASK_STATUS_COMPLETED\x10\x05\x12\x19\n" +
        "\x15TASK_STATUS_CANCELLED\x10\x06*`\n" +
        "\aTagType\x12\x18\n" +
        "\x14TAG_TYPE_UNSPECIFIED\x10\x00\x12\x11\n" +
        "\rTAG_TYPE_TEXT\x10\x01\x12\x15\n" +
        "\x11TAG_TYPE_LOCATION\x10\x02\x12\x11\n" +
        "\rTAG_TYPE_TIME\x10\x03*\x90\x01\n" +
        "\x10NotificationType\x12!\n" +
        "\x1dNOTIFICATION_TYPE_UNSPECIFIED\x10\x00\x12\x1a\n" +
        "\x16NOTIFICATION_ON_ASSIGN\x10\x01\x12\x19\n" +
        "\x15NOTIFICATION_ON_START\x10\x02\x12\"\n" +
        "\x1eNOTIFICATION_N_DAYS_BEFORE_DUE\x10\x032\xb1\t\n" +
        "\vTaskService\x12D\n" +
        "\aAddTask\x12\x1b.taskcore.v1.AddTaskRequest\x1a\x1c.taskcore.v1.AddTaskResponse\x12V\n" +
        "\rMoveToStaging\x12!.taskcore.v1.MoveToStagingRequest\x1a\".taskcore.v1.MoveToStagingResponse\x12J\n" +
        "\tStartTask\x12\x1d.taskcore.v1.StartTaskRequest\x1a\x1e.taskcore.v1.StartTaskResponse\x12G\n" +
        "\bStopTask\x12\x1c.taskcore.v1.StopTaskRequest\x1a\x1d.taskcore.v1.StopTaskResponse\x12S\n" +
        "\fCompleteTask\x12 .taskcore.v1.CompleteTaskRequest\x1a!.taskcore.v1.CompleteTaskResponse\x12M\n" +
        "\n" +
        "MergeTasks\x12\x1e.taskcore.v1.MergeTasksRequest\x1a\x1f.taskcore.v1.MergeTasksResponse\x12J\n" +
        "\tSplitTask\x12\x1d.taskcore.v1.SplitTaskRequest\x1a\x1e.taskcore.v1.SplitTaskResponse\x12V\n" +
        "\rAdvertiseTask\x12!.taskcore.v1.AdvertiseTaskRequest\x1a\".taskcore.v1.AdvertiseTaskResponse\x12P\n" +
        "\vStitchTasks\x12\x1f.taskcore.v1.StitchTasksRequest\x1a .taskcore.v1.StitchTasksResponse\x12J\n" +
        "\tListTasks\x12\x1d.taskcore.v1.ListTasksRequest\x1a\x1e.taskcore.v1.ListTasksResponse\x12D\n" +
        "\aGetTask\x12\x1b.taskcore.v1.GetTaskRequest\x1a\x1c.taskcore.v1.GetTaskResponse\x12Y\n" +
        "\x0eUpdateTaskTags\x12\".taskcore.v1.UpdateTaskTagsRequest\x1a#.taskcore.v1.UpdateTaskTagsResponse\x12S\n" +
        "\fSyncCalendar\x12 .taskcore.v1.SyncCalendarRequest\x1a!.taskcore.v1.SyncCalendarResponse\x12D\n" +
        "\aGetUser\x12\x1b.taskcore.v1.GetUserRequest\x1a\x1c.taskcore.v1.GetUserResponse\x12M\n" +
        "\n" +
        "UpdateUser\x12\x1e.taskcore.v1.UpdateUserRequest\x1a\x1f.taskcore.v1.UpdateUserResponseB&gt;Z&lt;github.com/DaDevFox/task-systems/task-core/proto/taskcore/v1b\x06proto3"

var (
        file_task_proto_rawDescOnce sync.Once
        file_task_proto_rawDescData []byte
)

func file_task_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_task_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_task_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_task_proto_rawDesc), len(file_task_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_task_proto_rawDescData</span>
}

var file_task_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_task_proto_msgTypes = make([]protoimpl.MessageInfo, 44)
var file_task_proto_goTypes = []any{
        (TaskStage)(0),                               // 0: taskcore.v1.TaskStage
        (TaskStatus)(0),                              // 1: taskcore.v1.TaskStatus
        (TagType)(0),                                 // 2: taskcore.v1.TagType
        (NotificationType)(0),                        // 3: taskcore.v1.NotificationType
        (*User)(nil),                                 // 4: taskcore.v1.User
        (*NotificationSetting)(nil),                  // 5: taskcore.v1.NotificationSetting
        (*TagValue)(nil),                             // 6: taskcore.v1.TagValue
        (*GeographicLocation)(nil),                   // 7: taskcore.v1.GeographicLocation
        (*Point)(nil),                                // 8: taskcore.v1.Point
        (*WorkInterval)(nil),                         // 9: taskcore.v1.WorkInterval
        (*Schedule)(nil),                             // 10: taskcore.v1.Schedule
        (*StatusUpdate)(nil),                         // 11: taskcore.v1.StatusUpdate
        (*Status)(nil),                               // 12: taskcore.v1.Status
        (*Task)(nil),                                 // 13: taskcore.v1.Task
        (*AddTaskRequest)(nil),                       // 14: taskcore.v1.AddTaskRequest
        (*AddTaskResponse)(nil),                      // 15: taskcore.v1.AddTaskResponse
        (*UpdateTaskTagsRequest)(nil),                // 16: taskcore.v1.UpdateTaskTagsRequest
        (*UpdateTaskTagsResponse)(nil),               // 17: taskcore.v1.UpdateTaskTagsResponse
        (*SyncCalendarRequest)(nil),                  // 18: taskcore.v1.SyncCalendarRequest
        (*SyncCalendarResponse)(nil),                 // 19: taskcore.v1.SyncCalendarResponse
        (*GetUserRequest)(nil),                       // 20: taskcore.v1.GetUserRequest
        (*GetUserResponse)(nil),                      // 21: taskcore.v1.GetUserResponse
        (*UpdateUserRequest)(nil),                    // 22: taskcore.v1.UpdateUserRequest
        (*UpdateUserResponse)(nil),                   // 23: taskcore.v1.UpdateUserResponse
        (*MoveToStagingRequest)(nil),                 // 24: taskcore.v1.MoveToStagingRequest
        (*MoveToStagingResponse)(nil),                // 25: taskcore.v1.MoveToStagingResponse
        (*StartTaskRequest)(nil),                     // 26: taskcore.v1.StartTaskRequest
        (*StartTaskResponse)(nil),                    // 27: taskcore.v1.StartTaskResponse
        (*StopTaskRequest)(nil),                      // 28: taskcore.v1.StopTaskRequest
        (*StopTaskResponse)(nil),                     // 29: taskcore.v1.StopTaskResponse
        (*CompleteTaskRequest)(nil),                  // 30: taskcore.v1.CompleteTaskRequest
        (*CompleteTaskResponse)(nil),                 // 31: taskcore.v1.CompleteTaskResponse
        (*MergeTasksRequest)(nil),                    // 32: taskcore.v1.MergeTasksRequest
        (*MergeTasksResponse)(nil),                   // 33: taskcore.v1.MergeTasksResponse
        (*SplitTaskRequest)(nil),                     // 34: taskcore.v1.SplitTaskRequest
        (*SplitTaskResponse)(nil),                    // 35: taskcore.v1.SplitTaskResponse
        (*AdvertiseTaskRequest)(nil),                 // 36: taskcore.v1.AdvertiseTaskRequest
        (*AdvertiseTaskResponse)(nil),                // 37: taskcore.v1.AdvertiseTaskResponse
        (*StitchTasksRequest)(nil),                   // 38: taskcore.v1.StitchTasksRequest
        (*StitchTasksResponse)(nil),                  // 39: taskcore.v1.StitchTasksResponse
        (*ListTasksRequest)(nil),                     // 40: taskcore.v1.ListTasksRequest
        (*ListTasksResponse)(nil),                    // 41: taskcore.v1.ListTasksResponse
        (*GetTaskRequest)(nil),                       // 42: taskcore.v1.GetTaskRequest
        (*GetTaskResponse)(nil),                      // 43: taskcore.v1.GetTaskResponse
        nil,                                          // 44: taskcore.v1.Task.TagsEntry
        nil,                                          // 45: taskcore.v1.UpdateTaskTagsRequest.TagsEntry
        nil,                                          // 46: taskcore.v1.MoveToStagingRequest.TagsEntry
        (*MoveToStagingRequest_NewLocationList)(nil), // 47: taskcore.v1.MoveToStagingRequest.NewLocationList
        (*timestamppb.Timestamp)(nil),                // 48: google.protobuf.Timestamp
}
var file_task_proto_depIdxs = []int32{
        5,  // 0: taskcore.v1.User.notification_settings:type_name -&gt; taskcore.v1.NotificationSetting
        3,  // 1: taskcore.v1.NotificationSetting.type:type_name -&gt; taskcore.v1.NotificationType
        2,  // 2: taskcore.v1.TagValue.type:type_name -&gt; taskcore.v1.TagType
        7,  // 3: taskcore.v1.TagValue.location_value:type_name -&gt; taskcore.v1.GeographicLocation
        48, // 4: taskcore.v1.TagValue.time_value:type_name -&gt; google.protobuf.Timestamp
        48, // 5: taskcore.v1.WorkInterval.start:type_name -&gt; google.protobuf.Timestamp
        48, // 6: taskcore.v1.WorkInterval.stop:type_name -&gt; google.protobuf.Timestamp
        8,  // 7: taskcore.v1.WorkInterval.points_completed:type_name -&gt; taskcore.v1.Point
        9,  // 8: taskcore.v1.Schedule.work_intervals:type_name -&gt; taskcore.v1.WorkInterval
        48, // 9: taskcore.v1.Schedule.due:type_name -&gt; google.protobuf.Timestamp
        48, // 10: taskcore.v1.StatusUpdate.time:type_name -&gt; google.protobuf.Timestamp
        11, // 11: taskcore.v1.Status.updates:type_name -&gt; taskcore.v1.StatusUpdate
        0,  // 12: taskcore.v1.Task.stage:type_name -&gt; taskcore.v1.TaskStage
        8,  // 13: taskcore.v1.Task.points:type_name -&gt; taskcore.v1.Point
        10, // 14: taskcore.v1.Task.schedule:type_name -&gt; taskcore.v1.Schedule
        12, // 15: taskcore.v1.Task.status:type_name -&gt; taskcore.v1.Status
        44, // 16: taskcore.v1.Task.tags:type_name -&gt; taskcore.v1.Task.TagsEntry
        13, // 17: taskcore.v1.AddTaskResponse.task:type_name -&gt; taskcore.v1.Task
        45, // 18: taskcore.v1.UpdateTaskTagsRequest.tags:type_name -&gt; taskcore.v1.UpdateTaskTagsRequest.TagsEntry
        13, // 19: taskcore.v1.UpdateTaskTagsResponse.task:type_name -&gt; taskcore.v1.Task
        4,  // 20: taskcore.v1.GetUserResponse.user:type_name -&gt; taskcore.v1.User
        4,  // 21: taskcore.v1.UpdateUserRequest.user:type_name -&gt; taskcore.v1.User
        4,  // 22: taskcore.v1.UpdateUserResponse.user:type_name -&gt; taskcore.v1.User
        47, // 23: taskcore.v1.MoveToStagingRequest.new_location:type_name -&gt; taskcore.v1.MoveToStagingRequest.NewLocationList
        8,  // 24: taskcore.v1.MoveToStagingRequest.points:type_name -&gt; taskcore.v1.Point
        46, // 25: taskcore.v1.MoveToStagingRequest.tags:type_name -&gt; taskcore.v1.MoveToStagingRequest.TagsEntry
        13, // 26: taskcore.v1.MoveToStagingResponse.task:type_name -&gt; taskcore.v1.Task
        13, // 27: taskcore.v1.StartTaskResponse.task:type_name -&gt; taskcore.v1.Task
        8,  // 28: taskcore.v1.StopTaskRequest.points_completed:type_name -&gt; taskcore.v1.Point
        13, // 29: taskcore.v1.StopTaskResponse.task:type_name -&gt; taskcore.v1.Task
        13, // 30: taskcore.v1.CompleteTaskResponse.task:type_name -&gt; taskcore.v1.Task
        13, // 31: taskcore.v1.MergeTasksResponse.merged_task:type_name -&gt; taskcore.v1.Task
        13, // 32: taskcore.v1.SplitTaskResponse.new_tasks:type_name -&gt; taskcore.v1.Task
        13, // 33: taskcore.v1.AdvertiseTaskResponse.task:type_name -&gt; taskcore.v1.Task
        13, // 34: taskcore.v1.StitchTasksResponse.updated_tasks:type_name -&gt; taskcore.v1.Task
        0,  // 35: taskcore.v1.ListTasksRequest.stage:type_name -&gt; taskcore.v1.TaskStage
        13, // 36: taskcore.v1.ListTasksResponse.tasks:type_name -&gt; taskcore.v1.Task
        13, // 37: taskcore.v1.GetTaskResponse.task:type_name -&gt; taskcore.v1.Task
        6,  // 38: taskcore.v1.Task.TagsEntry.value:type_name -&gt; taskcore.v1.TagValue
        6,  // 39: taskcore.v1.UpdateTaskTagsRequest.TagsEntry.value:type_name -&gt; taskcore.v1.TagValue
        6,  // 40: taskcore.v1.MoveToStagingRequest.TagsEntry.value:type_name -&gt; taskcore.v1.TagValue
        14, // 41: taskcore.v1.TaskService.AddTask:input_type -&gt; taskcore.v1.AddTaskRequest
        24, // 42: taskcore.v1.TaskService.MoveToStaging:input_type -&gt; taskcore.v1.MoveToStagingRequest
        26, // 43: taskcore.v1.TaskService.StartTask:input_type -&gt; taskcore.v1.StartTaskRequest
        28, // 44: taskcore.v1.TaskService.StopTask:input_type -&gt; taskcore.v1.StopTaskRequest
        30, // 45: taskcore.v1.TaskService.CompleteTask:input_type -&gt; taskcore.v1.CompleteTaskRequest
        32, // 46: taskcore.v1.TaskService.MergeTasks:input_type -&gt; taskcore.v1.MergeTasksRequest
        34, // 47: taskcore.v1.TaskService.SplitTask:input_type -&gt; taskcore.v1.SplitTaskRequest
        36, // 48: taskcore.v1.TaskService.AdvertiseTask:input_type -&gt; taskcore.v1.AdvertiseTaskRequest
        38, // 49: taskcore.v1.TaskService.StitchTasks:input_type -&gt; taskcore.v1.StitchTasksRequest
        40, // 50: taskcore.v1.TaskService.ListTasks:input_type -&gt; taskcore.v1.ListTasksRequest
        42, // 51: taskcore.v1.TaskService.GetTask:input_type -&gt; taskcore.v1.GetTaskRequest
        16, // 52: taskcore.v1.TaskService.UpdateTaskTags:input_type -&gt; taskcore.v1.UpdateTaskTagsRequest
        18, // 53: taskcore.v1.TaskService.SyncCalendar:input_type -&gt; taskcore.v1.SyncCalendarRequest
        20, // 54: taskcore.v1.TaskService.GetUser:input_type -&gt; taskcore.v1.GetUserRequest
        22, // 55: taskcore.v1.TaskService.UpdateUser:input_type -&gt; taskcore.v1.UpdateUserRequest
        15, // 56: taskcore.v1.TaskService.AddTask:output_type -&gt; taskcore.v1.AddTaskResponse
        25, // 57: taskcore.v1.TaskService.MoveToStaging:output_type -&gt; taskcore.v1.MoveToStagingResponse
        27, // 58: taskcore.v1.TaskService.StartTask:output_type -&gt; taskcore.v1.StartTaskResponse
        29, // 59: taskcore.v1.TaskService.StopTask:output_type -&gt; taskcore.v1.StopTaskResponse
        31, // 60: taskcore.v1.TaskService.CompleteTask:output_type -&gt; taskcore.v1.CompleteTaskResponse
        33, // 61: taskcore.v1.TaskService.MergeTasks:output_type -&gt; taskcore.v1.MergeTasksResponse
        35, // 62: taskcore.v1.TaskService.SplitTask:output_type -&gt; taskcore.v1.SplitTaskResponse
        37, // 63: taskcore.v1.TaskService.AdvertiseTask:output_type -&gt; taskcore.v1.AdvertiseTaskResponse
        39, // 64: taskcore.v1.TaskService.StitchTasks:output_type -&gt; taskcore.v1.StitchTasksResponse
        41, // 65: taskcore.v1.TaskService.ListTasks:output_type -&gt; taskcore.v1.ListTasksResponse
        43, // 66: taskcore.v1.TaskService.GetTask:output_type -&gt; taskcore.v1.GetTaskResponse
        17, // 67: taskcore.v1.TaskService.UpdateTaskTags:output_type -&gt; taskcore.v1.UpdateTaskTagsResponse
        19, // 68: taskcore.v1.TaskService.SyncCalendar:output_type -&gt; taskcore.v1.SyncCalendarResponse
        21, // 69: taskcore.v1.TaskService.GetUser:output_type -&gt; taskcore.v1.GetUserResponse
        23, // 70: taskcore.v1.TaskService.UpdateUser:output_type -&gt; taskcore.v1.UpdateUserResponse
        56, // [56:71] is the sub-list for method output_type
        41, // [41:56] is the sub-list for method input_type
        41, // [41:41] is the sub-list for extension type_name
        41, // [41:41] is the sub-list for extension extendee
        0,  // [0:41] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_task_proto_init() }</span>
func file_task_proto_init() <span class="cov0" title="0">{
        if File_task_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_task_proto_msgTypes[2].OneofWrappers = []any{
                (*TagValue_TextValue)(nil),
                (*TagValue_LocationValue)(nil),
                (*TagValue_TimeValue)(nil),
        }
        file_task_proto_msgTypes[20].OneofWrappers = []any{
                (*MoveToStagingRequest_DestinationId)(nil),
                (*MoveToStagingRequest_NewLocation)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_task_proto_rawDesc), len(file_task_proto_rawDesc)),
                        NumEnums:      4,
                        NumMessages:   44,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_task_proto_goTypes,
                DependencyIndexes: file_task_proto_depIdxs,
                EnumInfos:         file_task_proto_enumTypes,
                MessageInfos:      file_task_proto_msgTypes,
        }.Build()
        File_task_proto = out.File
        file_task_proto_goTypes = nil
        file_task_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: task.proto

package v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        TaskService_AddTask_FullMethodName        = "/taskcore.v1.TaskService/AddTask"
        TaskService_MoveToStaging_FullMethodName  = "/taskcore.v1.TaskService/MoveToStaging"
        TaskService_StartTask_FullMethodName      = "/taskcore.v1.TaskService/StartTask"
        TaskService_StopTask_FullMethodName       = "/taskcore.v1.TaskService/StopTask"
        TaskService_CompleteTask_FullMethodName   = "/taskcore.v1.TaskService/CompleteTask"
        TaskService_MergeTasks_FullMethodName     = "/taskcore.v1.TaskService/MergeTasks"
        TaskService_SplitTask_FullMethodName      = "/taskcore.v1.TaskService/SplitTask"
        TaskService_AdvertiseTask_FullMethodName  = "/taskcore.v1.TaskService/AdvertiseTask"
        TaskService_StitchTasks_FullMethodName    = "/taskcore.v1.TaskService/StitchTasks"
        TaskService_ListTasks_FullMethodName      = "/taskcore.v1.TaskService/ListTasks"
        TaskService_GetTask_FullMethodName        = "/taskcore.v1.TaskService/GetTask"
        TaskService_UpdateTaskTags_FullMethodName = "/taskcore.v1.TaskService/UpdateTaskTags"
        TaskService_SyncCalendar_FullMethodName   = "/taskcore.v1.TaskService/SyncCalendar"
        TaskService_GetUser_FullMethodName        = "/taskcore.v1.TaskService/GetUser"
        TaskService_UpdateUser_FullMethodName     = "/taskcore.v1.TaskService/UpdateUser"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service definition
type TaskServiceClient interface {
        AddTask(ctx context.Context, in *AddTaskRequest, opts ...grpc.CallOption) (*AddTaskResponse, error)
        MoveToStaging(ctx context.Context, in *MoveToStagingRequest, opts ...grpc.CallOption) (*MoveToStagingResponse, error)
        StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error)
        StopTask(ctx context.Context, in *StopTaskRequest, opts ...grpc.CallOption) (*StopTaskResponse, error)
        CompleteTask(ctx context.Context, in *CompleteTaskRequest, opts ...grpc.CallOption) (*CompleteTaskResponse, error)
        MergeTasks(ctx context.Context, in *MergeTasksRequest, opts ...grpc.CallOption) (*MergeTasksResponse, error)
        SplitTask(ctx context.Context, in *SplitTaskRequest, opts ...grpc.CallOption) (*SplitTaskResponse, error)
        AdvertiseTask(ctx context.Context, in *AdvertiseTaskRequest, opts ...grpc.CallOption) (*AdvertiseTaskResponse, error)
        StitchTasks(ctx context.Context, in *StitchTasksRequest, opts ...grpc.CallOption) (*StitchTasksResponse, error)
        ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
        GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error)
        UpdateTaskTags(ctx context.Context, in *UpdateTaskTagsRequest, opts ...grpc.CallOption) (*UpdateTaskTagsResponse, error)
        SyncCalendar(ctx context.Context, in *SyncCalendarRequest, opts ...grpc.CallOption) (*SyncCalendarResponse, error)
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
        UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
}

type taskServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient <span class="cov0" title="0">{
        return &amp;taskServiceClient{cc}
}</span>

func (c *taskServiceClient) AddTask(ctx context.Context, in *AddTaskRequest, opts ...grpc.CallOption) (*AddTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_AddTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) MoveToStaging(ctx context.Context, in *MoveToStagingRequest, opts ...grpc.CallOption) (*MoveToStagingResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(MoveToStagingResponse)
        err := c.cc.Invoke(ctx, TaskService_MoveToStaging_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StartTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_StartTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) StopTask(ctx context.Context, in *StopTaskRequest, opts ...grpc.CallOption) (*StopTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StopTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_StopTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) CompleteTask(ctx context.Context, in *CompleteTaskRequest, opts ...grpc.CallOption) (*CompleteTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CompleteTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_CompleteTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) MergeTasks(ctx context.Context, in *MergeTasksRequest, opts ...grpc.CallOption) (*MergeTasksResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(MergeTasksResponse)
        err := c.cc.Invoke(ctx, TaskService_MergeTasks_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) SplitTask(ctx context.Context, in *SplitTaskRequest, opts ...grpc.CallOption) (*SplitTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SplitTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_SplitTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) AdvertiseTask(ctx context.Context, in *AdvertiseTaskRequest, opts ...grpc.CallOption) (*AdvertiseTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AdvertiseTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_AdvertiseTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) StitchTasks(ctx context.Context, in *StitchTasksRequest, opts ...grpc.CallOption) (*StitchTasksResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StitchTasksResponse)
        err := c.cc.Invoke(ctx, TaskService_StitchTasks_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListTasksResponse)
        err := c.cc.Invoke(ctx, TaskService_ListTasks_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*GetTaskResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTaskResponse)
        err := c.cc.Invoke(ctx, TaskService_GetTask_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) UpdateTaskTags(ctx context.Context, in *UpdateTaskTagsRequest, opts ...grpc.CallOption) (*UpdateTaskTagsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateTaskTagsResponse)
        err := c.cc.Invoke(ctx, TaskService_UpdateTaskTags_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) SyncCalendar(ctx context.Context, in *SyncCalendarRequest, opts ...grpc.CallOption) (*SyncCalendarResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SyncCalendarResponse)
        err := c.cc.Invoke(ctx, TaskService_SyncCalendar_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserResponse)
        err := c.cc.Invoke(ctx, TaskService_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *taskServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateUserResponse)
        err := c.cc.Invoke(ctx, TaskService_UpdateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
//
// Service definition
type TaskServiceServer interface {
        AddTask(context.Context, *AddTaskRequest) (*AddTaskResponse, error)
        MoveToStaging(context.Context, *MoveToStagingRequest) (*MoveToStagingResponse, error)
        StartTask(context.Context, *StartTaskRequest) (*StartTaskResponse, error)
        StopTask(context.Context, *StopTaskRequest) (*StopTaskResponse, error)
        CompleteTask(context.Context, *CompleteTaskRequest) (*CompleteTaskResponse, error)
        MergeTasks(context.Context, *MergeTasksRequest) (*MergeTasksResponse, error)
        SplitTask(context.Context, *SplitTaskRequest) (*SplitTaskResponse, error)
        AdvertiseTask(context.Context, *AdvertiseTaskRequest) (*AdvertiseTaskResponse, error)
        StitchTasks(context.Context, *StitchTasksRequest) (*StitchTasksResponse, error)
        ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
        GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error)
        UpdateTaskTags(context.Context, *UpdateTaskTagsRequest) (*UpdateTaskTagsResponse, error)
        SyncCalendar(context.Context, *SyncCalendarRequest) (*SyncCalendarResponse, error)
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
        UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
        mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) AddTask(context.Context, *AddTaskRequest) (*AddTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) MoveToStaging(context.Context, *MoveToStagingRequest) (*MoveToStagingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MoveToStaging not implemented")
}</span>
func (UnimplementedTaskServiceServer) StartTask(context.Context, *StartTaskRequest) (*StartTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StartTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) StopTask(context.Context, *StopTaskRequest) (*StopTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StopTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) CompleteTask(context.Context, *CompleteTaskRequest) (*CompleteTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CompleteTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) MergeTasks(context.Context, *MergeTasksRequest) (*MergeTasksResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MergeTasks not implemented")
}</span>
func (UnimplementedTaskServiceServer) SplitTask(context.Context, *SplitTaskRequest) (*SplitTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SplitTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) AdvertiseTask(context.Context, *AdvertiseTaskRequest) (*AdvertiseTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AdvertiseTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) StitchTasks(context.Context, *StitchTasksRequest) (*StitchTasksResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StitchTasks not implemented")
}</span>
func (UnimplementedTaskServiceServer) ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}</span>
func (UnimplementedTaskServiceServer) GetTask(context.Context, *GetTaskRequest) (*GetTaskResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}</span>
func (UnimplementedTaskServiceServer) UpdateTaskTags(context.Context, *UpdateTaskTagsRequest) (*UpdateTaskTagsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateTaskTags not implemented")
}</span>
func (UnimplementedTaskServiceServer) SyncCalendar(context.Context, *SyncCalendarRequest) (*SyncCalendarResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SyncCalendar not implemented")
}</span>
func (UnimplementedTaskServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedTaskServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}</span>
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
        mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedTaskServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;TaskService_ServiceDesc, srv)</span>
}

func _TaskService_AddTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).AddTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_AddTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).AddTask(ctx, req.(*AddTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_MoveToStaging_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MoveToStagingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).MoveToStaging(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_MoveToStaging_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).MoveToStaging(ctx, req.(*MoveToStagingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StartTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).StartTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_StartTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).StartTask(ctx, req.(*StartTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_StopTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StopTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).StopTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_StopTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).StopTask(ctx, req.(*StopTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_CompleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CompleteTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).CompleteTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_CompleteTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).CompleteTask(ctx, req.(*CompleteTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_MergeTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MergeTasksRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).MergeTasks(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_MergeTasks_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).MergeTasks(ctx, req.(*MergeTasksRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_SplitTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SplitTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).SplitTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_SplitTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).SplitTask(ctx, req.(*SplitTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_AdvertiseTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AdvertiseTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).AdvertiseTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_AdvertiseTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).AdvertiseTask(ctx, req.(*AdvertiseTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_StitchTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StitchTasksRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).StitchTasks(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_StitchTasks_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).StitchTasks(ctx, req.(*StitchTasksRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListTasksRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).ListTasks(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_ListTasks_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).ListTasks(ctx, req.(*ListTasksRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTaskRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).GetTask(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_GetTask_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).GetTask(ctx, req.(*GetTaskRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_UpdateTaskTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateTaskTagsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).UpdateTaskTags(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_UpdateTaskTags_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).UpdateTaskTags(ctx, req.(*UpdateTaskTagsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_SyncCalendar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SyncCalendarRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).SyncCalendar(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_SyncCalendar_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).SyncCalendar(ctx, req.(*SyncCalendarRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TaskService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).UpdateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TaskService_UpdateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TaskServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "taskcore.v1.TaskService",
        HandlerType: (*TaskServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "AddTask",
                        Handler:    _TaskService_AddTask_Handler,
                },
                {
                        MethodName: "MoveToStaging",
                        Handler:    _TaskService_MoveToStaging_Handler,
                },
                {
                        MethodName: "StartTask",
                        Handler:    _TaskService_StartTask_Handler,
                },
                {
                        MethodName: "StopTask",
                        Handler:    _TaskService_StopTask_Handler,
                },
                {
                        MethodName: "CompleteTask",
                        Handler:    _TaskService_CompleteTask_Handler,
                },
                {
                        MethodName: "MergeTasks",
                        Handler:    _TaskService_MergeTasks_Handler,
                },
                {
                        MethodName: "SplitTask",
                        Handler:    _TaskService_SplitTask_Handler,
                },
                {
                        MethodName: "AdvertiseTask",
                        Handler:    _TaskService_AdvertiseTask_Handler,
                },
                {
                        MethodName: "StitchTasks",
                        Handler:    _TaskService_StitchTasks_Handler,
                },
                {
                        MethodName: "ListTasks",
                        Handler:    _TaskService_ListTasks_Handler,
                },
                {
                        MethodName: "GetTask",
                        Handler:    _TaskService_GetTask_Handler,
                },
                {
                        MethodName: "UpdateTaskTags",
                        Handler:    _TaskService_UpdateTaskTags_Handler,
                },
                {
                        MethodName: "SyncCalendar",
                        Handler:    _TaskService_SyncCalendar_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _TaskService_GetUser_Handler,
                },
                {
                        MethodName: "UpdateUser",
                        Handler:    _TaskService_UpdateUser_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "task.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
